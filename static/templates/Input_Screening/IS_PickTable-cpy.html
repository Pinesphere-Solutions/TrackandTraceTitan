{% extends "base.html" %} 
{% load static %}
{% load stock_filters %} 

 {% block content %}



<div class="content-wrapper">
    <div class="col-12 grid-margin stretch-card">
      <div class="card">
                <div class="card-body" style="padding-bottom:12px;">
          <h5 class="text-left mt-0 mb-4" style="font-weight:700;">Input Screening Pick Table</h5>
          
            <div class="table-responsive" style="overflow: scroll !important">
              <table id="order-listing" class="table">
                <thead>
                    <tr>
                      <th>
                      S.No <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Last<br>Updated
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polishing Stk No
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Plating Color
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                     <th>
                      Category
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Polish Finish
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Tray Cate- <br> Capacity
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Input Source
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      IPA Wiping
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    
                    <th>
                      No of Trays <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      LOT Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Physical Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>

                    <th>
                      Accept Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                      </th>
                    <th>
                      Reject Qty
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Process Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Action <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Lot Status
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Current Stage
                      <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                    <th>
                      Remarks <i class="fa fa-filter" aria-hidden="true"></i>
                    </th>
                   
                  </tr>
                </thead>
                <tbody>
                  <!-- Row 1 - Highlighted -->
                   {% for data in master_data %}
                <tr class="highlighted-tray-scan{% if data.ip_hold_lot %} row-inactive{% endif %}"
                    data-stock-lot-id="{{ data.stock_lot_id }}"
                    data-batch-id="{{ data.batch_id }}"
                    data-available-qty="{{ data.available_qty }}"
                    data-ip-onhold-picking="{{ data.ip_onhold_picking }}"
                    data-few-cases-acceptance="{{data.few_cases_accepted_Ip_stock}}"
                      data-model-no="{{ data.plating_stk_no }}">
                    
                  <td {% if data.ip_hold_lot %} class="row-inactive-blur"{% endif %}>
                    <span style="display:flex; align-items:center; gap:3px;">
                      {% if is_admin %}
                        <!-- Admin users: Show toggle switch -->
                        <label class="hold-toggle-switch" style="margin-bottom:0;">
                          {% if not data.ip_hold_lot %}
                            <input type="checkbox" class="hold-toggle-btn" checked />
                            <span class="hold-slider"></span>
                          {% else %}
                            <input type="checkbox" class="hold-toggle-btn" />
                            <span class="hold-slider"></span>
                          {% endif %}
                        </label>
                        <!-- Hold remark icon -->
                        <span class="hold-remark-icon" 
                              style="display:{% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}inline-block{% else %}none{% endif %}; cursor:pointer;" 
                              title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
                          {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
                            <img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:12px; height:12px;" />
                          {% endif %}
                        </span>
                      {% else %}
                        <!-- Non-admin: Only show view icon if there's a holding/release reason -->
                        {% if data.ip_hold_lot or data.ip_release_lot or data.ip_holding_reason or data.ip_release_reason %}
                          <span class="hold-remark-icon" 
                                style="display:inline-block; cursor:pointer;" 
                                title="{% if data.ip_holding_reason %}Holding Reason: {{ data.ip_holding_reason }}{% endif %}{% if data.ip_holding_reason and data.ip_release_reason %}&#10;{% endif %}{% if data.ip_release_reason %}Release Reason: {{ data.ip_release_reason }}{% endif %}">
                            <img src="{% static 'assets/icons/view2.png' %}" alt="View Reason" style="width:18px; height:18px;" />
                          </span>
                        {% endif %}
                      {% endif %}
                      <span class="sno-value">{{ page_obj.start_index|add:forloop.counter0 }}</span>
                    </span>
                  </td>             
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                              {{ data.created_at|date:"d-M-y"  }}<br>
                        <span style="display:inline-block; margin-top:4px;">{{ data.created_at|date:"h:i A" }}</span>
                        </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        <span class="model-hover-trigger" style="cursor: pointer;">
                          {{ data.plating_stk_no|highlight_plating_color|safe_html }}
                          <div class="model-image-tooltip" style="position: absolute; left: 50%; top: 110%; transform: translateX(-50%); background: #fff; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); padding: 12px 18px; z-index: 9999; display: flex; align-items: center; gap: 8px; opacity: 0; pointer-events: none; transition: opacity 0.2s;">
                            <button class="img-scroll-left" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8592;</button>
                            <div class="img-gallery" style="display: flex; gap: 6px; overflow: hidden; width: 180px;">
                              {% for img_url in data.model_images %}
                                <img src="{{ img_url }}" style="width: 55px; height: 55px; object-fit: cover; border-radius: 6px;" />
                              {% endfor %}
                            </div>
                            <button class="img-scroll-right" style="background: none; border: none; font-size: 20px; cursor: pointer;">&#8594;</button>
                          </div>
                        </span>
                    </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.polishing_stk_no|default:"N/A"|highlight_polish_finish|safe_html }}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.plating_color }}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{ data.category }}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.polish_finish}}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.tray_type}}-{{data.tray_capacity}}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.location__location_name}}</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {% if data.wiping_required %}
                        YES
                      {% else %}
                        No
                      {% endif %}
                    </td>
                                        <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>{{data.no_of_trays}}</td>

                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <span class="lot-qty" style="min-width: 30px; text-align: right">{{ data.total_batch_quantity }}</span>
                      <span style="display: inline-flex; align-items: center; gap: 4px;">
                        <input type="checkbox"
                                class="ip-checkbox"
                                data-lot-id="{{ data.stock_lot_id }}"
                                style="width: 15px; height: 15px"
                                {% if data.ip_person_qty_verified %}checked disabled{% endif %} /
                        
                      </span>
                    </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <input
                        type="text"
                        class="physical-qty-input"
                        value="{{ data.dp_physical_qty }}"
                        style="width: 36px; padding: 1px 3px; font-size: 13px; border: 1px solid #ccc; border-radius: 4px;
                              {% if data.dp_physical_qty_edited %}background-color: #fff3cd; border-color: #ffc107;{% endif %}"
                        readonly
                        {% if data.dp_physical_qty_edited %}title="This quantity was edited"{% endif %}
                      />
                    </td>

                    
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{data.display_accepted_qty|default:0}}   
                    </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                        {{ data.ip_rejection_total_qty|default:0 }}
                    </td>
                    <!-- Process Status Column -->
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div class="process-status-group d-flex align-items-center justify-content-center" style="gap: 6px;">
                        <!-- Q icon -->
                        <div
                          title="Tray Scan"
                          class="d-flex align-items-center justify-content-center rounded-circle"
                          style="width: 28px; height: 28px; background-color: {% if data.ip_person_qty_verified %}#0c8249{% else %}#bdbdbd{% endif %}; color: white; font-weight: bold; font-size: 15px;">
                          Q
                        </div>
                        <!-- S icon -->
                        <div
                          title="Status"
                          class="d-flex align-items-center justify-content-center rounded-circle"
                          style="
                            width: 28px; height: 28px;
                            {% if data.accepted_tray_scan_status and data.few_cases_accepted_Ip_stock and not data.ip_onhold_picking %}
                              background-color: #0c8249;
                            {% elif data.ip_onhold_picking and data.few_cases_accepted_Ip_stock %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                            {% elif data.ip_onhold_picking  %}
                              background: linear-gradient(to right, #0c8249 50%, #bdbdbd 50%);
                            {% else %}
                              background-color: #bdbdbd;
                            {% endif %}
                            color: white; font-weight: bold; font-size: 15px;">
                          S
                        </div>
                      </div>
                    </td>
<td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
  {% if not data.accepted_Ip_stock and not data.rejected_ip_stock and not data.accepted_tray_scan_status %}
    

    <!-- Accept/Reject Buttons Section -->
    {% if data.few_cases_accepted_Ip_stock and data.ip_onhold_picking %}
      <button type="button" class="btn btn-social-icon-text btn-twitter"
              style="background-color: #66bb6a; pointer-events: none; opacity: 0.6; cursor: not-allowed;"
              disabled>
        <i class="fa fa-check-circle"></i>Accept
      </button>
      <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
              style="background-color: #e57373;"
              data-stock-lot-id="{{ data.stock_lot_id }}"
              data-batch-id="{{ data.batch_id }}"
        data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}">
        <i class="fa fa-times-circle"></i>Set Top Tray
      </button>
    {% else %}
    <!-- ✅ Show enabled delete button when Accept/Reject buttons are visible -->
    {% if is_admin%}
    <a href="#" class="delete-batch-btn" title="Delete" data-batch-id="{{ data.batch_id }}" data-stock-lot-id="{{ data.stock_lot_id }}">
      <img src="{% static 'assets/icons/bin.png' %}" alt="Delete" style="width: 20px; margin-right: 8px; height: auto" />
    </a>
    {% endif %}
      <button type="button" class="btn btn-social-icon-text btn-twitter"
              style="background-color: #66bb6a;"
              data-lot-id="{{ data.stock_lot_id }}"
        {% if not data.ip_person_qty_verified %}disabled{% endif %}>
        <i class="fa fa-check-circle"></i>Accept
      </button>
      <button type="button" class="btn btn-social-icon-text btn-youtube tray-scan-btn"
              style="background-color: #e57373;"
              data-stock-lot-id="{{ data.stock_lot_id }}"
              data-batch-id="{{ data.batch_id }}"
        data-dp-physical-qty="{{ data.dp_physical_qty|default:0 }}"
      {% if not data.ip_person_qty_verified %}disabled{% endif %}>
        <i class="fa fa-times-circle"></i>Reject
      </button>
    {% endif %}

    
  {% else %}

    <span title="Delete Disabled" style="opacity: 0.5; pointer-events: none;">
      <img src="{% static 'assets/icons/bin.png' %}" alt="Delete Disabled" style="width: 20px; margin-right: 8px; height: auto; filter: grayscale(1) opacity(0.5);" />
    </span>
  {% endif %}

  <!-- Eye icon to view submitted "Tray Scan Table" -->
  <a href="#"
    title="View"
    class="text-primary tray-scan-btn-DayPlanning-view tray-scan-btn-Jig"
    style="text-decoration: underline"
    data-stock-lot-id="{{ data.stock_lot_id }}"
    data-batch-id="{{ data.batch_id }}"
    data-model-no="{{ data.plating_stk_no }}"
    data-no-of-trays="{{ data.no_of_trays }}"
    data-tray-capacity="{{ data.tray_capacity|default:'0' }}"
    data-moved-to-d-picker="{{ data.Moved_to_D_Picker }}"
    data-tray-qty-list="{{ data.tray_qty_list|default:'[]'|safe }}"
    data-model-image="{{ data.model_images.0|default:'' }}"
    data-ip-person-qty-verified="{{ data.ip_person_qty_verified|yesno:'true,false' }}">

    <img src="{% static 'assets/icons/view.png' %}"
        alt="View"
        style="width: 20px; margin-right: 8px; height: auto; cursor:pointer;" />
  </a>
</td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {% if data.ip_hold_lot %}
                        <!-- When ip_hold_lot is True, show "On Hold" status -->
                        <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 2px solid #dc3545;
                            background-color: #f8d7da;
                            color: #721c24;
                            font-size: 13px;
                            white-space: nowrap;
                            padding-top: 0.5rem;
                            padding-bottom: 0.5rem;
                          "
                        >
                          On Hold
                        </div>
                        {% elif data.ip_onhold_picking %}
                        <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 1px solid #4997ac;
                            background-color: #d1f2f3;
                            color: #03425d;
                            font-size: 13px;
                            white-space: nowrap;
                            padding: 5px;
                          "
                        >
                          Draft
                        </div>
                      {% elif data.ip_onhold_picking and data.few_cases_accepted_Ip_stock %}
                        <div
                          class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                          style="
                            border: 1px solid #4997ac;
                            background-color: #d1f2f3;
                            color: #03425d;
                            font-size: 13px;
                            white-space: nowrap;
                            padding: 5px;
 "
                        >
                          Draft
                        </div>
                    
                      {% else %}
                        <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                            style="border: 1px solid #f9a825; background-color: #fff8e1; color: #b26a00; font-size: 13px; white-space: nowrap; padding: 0.3rem;">
                          Yet to Start
                        </div>
                      {% endif %}
                    </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      <div
                        class="d-inline-block px-3 fw-semibold text-center rounded-pill"
                        style="
                          border: 1px solid
                            {% if data.last_process_module == 'Input screening' %}
                              #0d5d17
                            {% elif data.last_process_module == 'Input screening' %}
                              #f9a825
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #1976d2
                            {% else %}
                              #9adeed
                            {% endif %};
                          background-color:
                            {% if data.last_process_module == 'Input screening' %}
                              #c5f9c2
                            {% elif data.last_process_module == 'Input screening' %}
                              #fff8e1
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #d1eaff
                            {% else %}
                              #d1edf3
                            {% endif %};
                          color:
                            {% if data.last_process_module == 'Input screening' %}
                              #2f801b
                            {% elif data.last_process_module == 'Input screening' %}
                              #b26a00
                            {% elif data.last_process_module == 'DayPlanning' %}
                              #033b5d
                            {% else %}
                              #033b5d
                            {% endif %};
                          font-size: 12px;
                          white-space: nowrap;
                          padding: 5px;
                        "
                      >
                        {{ data.last_process_module|default:"N/A" }}
                      </div>
                    </td>
                    <td {% if data.ip_hold_lot %} class="row-inactive-blur" {% endif %}>
                      {% if  data.ip_person_qty_verified %}
                          {% if data.ip_person_qty_verified %}

                            <!-- VoiceRec with tooltip (audio remark) -->
                              <a href="#" title="Add Audio Remark" class="remark-tooltip-trigger" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; position: relative; cursor: pointer;">
                                <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec" style="width: 20px; height: 20px"/>
                                <div class="remark-tooltip" style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 300px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;">
                                  <div style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid #fff;"></div>
                                  <!-- Audio recording UI placeholder -->
                                  <div style="display: flex; align-items: center; gap: 10px;">
                                    <button type="button" style="background: #28a745; color: #fff; border: none; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; display: flex; align-items: center; justify-content: center;">
                                      <i class="fa fa-microphone"></i>
                                    </button>
                                    <span style="font-size: 14px; color: #333;">Hold to record audio</span>
                                  </div>
                                  <div style="text-align: right; margin-top: 10px;">
                                    <button type="button" style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                      <i class="fa fa-send"></i>
                                    </button>
                                  </div>
                                </div>
                              </a>

                                <a
                              href="#"
                              title="Add Remark"
                              class="remark-tooltip-trigger"
                              style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; position: relative; cursor: pointer;"
                            >
                              <img
                                src="{% static 'assets/icons/chat1.png' %}"
                                alt="Chat"
                                style="width: 20px; height: 20px; {% if data.IP_pick_remarks %}filter: grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2); opacity: 1;{% endif %}"
                              />
                              <div
                                class="remark-tooltip"
                                style="position: absolute; top: 110%; left: 50%; transform: translateX(-50%); width: 300px; background: #fff; border: 1px solid #ccc; border-radius: 6px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; padding: 15px; z-index: 1000;"
                              >
                                <div
                                  style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 10px solid #fff;"
                                ></div>
                                <textarea
                                  placeholder="Type your remark..."
                                  style="width: 85%; height: 40px; resize: vertical; border: 1px solid #ccc; padding: 5px; border-radius: 4px; font-family: Arial, sans-serif; font-size: 14px;"
                                  {% if data.IP_pick_remarks %}readonly{% endif %}
                                >{{ data.IP_pick_remarks|default_if_none:"" }}</textarea>
                                <div style="text-align: right; margin-top: -35px">
                                  {% if not data.IP_pick_remarks %}
                                  <button
                                    type="button"
                                    style="background-color: #007bff; color: #fff; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;"
                                  >
                                    <i class="fa fa-send"></i>
                                  </button>
                                  {% else %}
                                  <div style="margin-top: 40px; color: #31708f; background: #d9edf7; border: 1px solid #bce8f1; border-radius: 4px; padding: 8px 12px; font-size: 10px; text-align: left;">
                                    <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                                    Remark already saved and cannot be edited.
                                  </div>
                                  {% endif %}
                                </div>
                              </div>
                              </a>
                         {% else %}

                                <!-- Audio Remark Icon (disabled) -->
                            <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;">
                              <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                            </span>
                            <!-- Chat Remark Icon (disabled) -->
                            <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;">
                              <img src="{% static 'assets/icons/chat1.png' %}" alt="Chat Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                            </span>
                            {% endif %}

                      {% else %}
                      <!-- Audio Remark Icon (disabled) -->
                      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 28px; margin-left: 0; opacity: 0.5; pointer-events: none;">
                        <img src="{% static 'assets/icons/rec.png' %}" alt="VoiceRec Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                      </span>
                      <!-- Chat Remark Icon (disabled) -->
                      <span title="Disabled after moved" style="display: inline-flex; align-items: center; height: 20px; margin-left: 5px; opacity: 0.5; pointer-events: none;">
                        <img src="{% static 'assets/icons/chat1.png' %}" alt="Chat Disabled" style="width: 20px; height: 20px; filter: grayscale(1) opacity(0.5);" />
                      </span>
                    {% endif %}
                    </td>
                   
                </tr>
                  {% endfor%}
                </tbody>
              </table>
                

              <!-- Tray Scan Modal for Input Screening -->
              <div
                id="trayScanModal_DayPlanning"
                class="tray-scan-modal-DayPlanning"
              >
                <div class="tray-scan-modal-DayPlanning-content">
                  <span id="closeTrayScanModal_DayPlanning" class="tray-scan-close-readonly"
                    >&times;</span
                  >
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                    class="modal-top-header"
                    style="
                      display: flex;
                      align-items: center;
                      gap: 20px;
                      padding-bottom: 10px;
                    "
                  >
                    <div
                      class="user-profile"
                      style="display: flex; align-items: center; gap: 8px"
                    >
                      <img
                        src="/static/assets/images/imagePlaceholder.png"
                        alt="User Profile"
                        style="
                          border-radius: 50%;
                          width: 50px;
                          height: 50px;
                          object-fit: cover;
                        "
                      />
                      <span>Model No:</span>
                      <h6 id="modalModelNo_DayPlanning">(Fetch Dynamically)</h6>
                    </div>
                  </div>
                  <!-- Redo icon for clearing "tray ID" -->

                  <div id="trayValidateSection" style="display: flex; align-items: center; gap: 12px; margin-bottom: 8px;">
                    <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                      Input Screening - Tray Scan
                    </h5>
                    <button id="trayValidateBtn" type="button" style="display: flex; align-items: center; gap: 6px; background: #f5faff; border: 1px solid #023E4DCC; color: #023E4DCC; border-radius: 20px; padding: 4px 14px; font-size: 12px; font-weight: 500; cursor: pointer;">
                      <img src="{% static 'assets/icons/barcode.png' %}" alt="Validate" style="width: 20px; height: 20px; margin-right: 4px;" />
                      Tray Validate
                    </button>
                    <span id="trayQtyRedoBtn" title="Reset Top Tray Qty" style="display:none; cursor:pointer; margin-left:6px;">
                      <img src="{% static 'assets/icons/redo2.png' %}" style="width:22px;vertical-align:middle;" />
                    </span>
                    <!-- Hidden input field -->
                    <input id="trayValidateInput" type="text" placeholder="Enter validation info..." style="position: absolute; left: -9999px; opacity: 0; pointer-events: none;" />
                  </div>
                  <!-- Add verification status indicator when buttons are hidden -->
                    <div id="verificationStatusIndicator" style="display: none; margin-bottom: 8px;">
                      <h5 style="text-align: center; margin: 0; font-weight: 600; color:#595959">
                        Input Screening - Tray Scan
                      
                      </h5>
                    </div>
                                      
                  <!-- Error message container - initially hidden -->
                  <div id="trayErrorMessage" style="display: none; background-color: #ffebee; border: 1px solid #f44336; color: #c62828; padding: 8px 12px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; text-align: center;">
                    <span id="trayErrorText"></span>
                  </div>
                  
                  <!-- trayScanDetails_DayPlanning will be a scrollable 3-column grid with headers and unlimited rows -->
                  <div id="trayScanDetails_DayPlanning" class="table-grid">
                    <!-- Headers -->
                    <div>S.no</div>
                    <div>Tray ID</div>
                    <div>Tray Quantity</div>
                    <div class="tray-validation-status-header">Tray Validation Status
                      <span style="margin-left: 10px;">
              <img src="{% static 'assets/icons/fail.png' %}" alt="Cross" title="Fail" style="width:18px; height:18px; margin-right:6px; vertical-align:middle;" />
              <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px; vertical-align:middle;" />
              </span>
                    </div>
                    <!-- Example rows (replace with dynamic content) -->
                  </div>
                  <!-- No buttons for read-only modal -->
                </div>
              </div>
               </div>
              <!-- Tray Scan Details Modal (Left Popup) -->
              <div id="trayScanModal" class="tray-scan-modal">
                <div class="tray-scan-modal-content">
                  <span id="closeTrayScanModal" class="tray-scan-close"
                    >&times;</span
                  >
                  <h3 id="trayScanModalHeader">Input Screening / <span class="modal-model-no"></span> / Rejection Window</h3>
                   <div id="trayScanDetails">
                    <!-- Dynamic content will be loaded here -->
                  </div>
                </div>
              </div>
              <!-- New Popup Modal (Right Popup) -->
              <div id="newPopupModal" class="new-popup-modal">
                <div class="tray-scan-modal-content">
                  <span id="closeNewPopupModal" class="tray-scan-close"
                    >&times;</span
                  >
                  <!-- New top header container: title + user profile aligned left -->
                  <div
                    class="modal-top-header"
                    style="
                      display: flex;
                      align-items: center;
                      gap: 20px;
                      padding-bottom: 10px;
                    "
                  >
                    <div
                      class="user-profile"
                      style="display: flex; align-items: center; gap: 8px"
                    >
                      <img
                        src="{% static 'assets/images/imagePlaceholder.png' %}"
                        alt="User Profile"
                        style="
                          border-radius: 50%;
                          width: 50px;
                          height: 50px;
                          object-fit: cover;
                        "
                      />
                      <span>Model No:</span>
                      <h6>(Fetch Dynamically) / Accepted Tray Rescan</h6>
                    </div>
                  </div>



                  
                  <!-- Existing centered h3 title -->
                  <!-- Redo icon for clearing "tray ID" -->
                 <div style="display: flex; align-items: center; justify-content: space-between; gap: 8px;">
                    <h5 style="text-align: center; margin: 0; flex: 1; font-weight: 600; color:#595959">
                      Accepted - Top Tray Scan
                    </h5>
                    <img
                      src="{% static 'assets/icons/redo2.png' %}"
                      alt="Redo"
                      
                      id="trayScanRedoBtn"
                      style="width: 24px; height: 24px; cursor: pointer; margin-right: 14px;"
                      title="Clear Tray IDs"
                    />
                  </div>
                  <!-- Accepted Case Tray Scan Table - Grid View with Visible Borders -->
                  <div id="trayScanDetails" class="table-grid">
                    
                    <!-- NEW BUTTONS SECTION -->
                    <div class="tray-scan-modal-buttons" style="grid-column: 1 / -1; display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
                       <button
                    style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                    Draft
                  </button>
                  <button
                    style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                    Submit
                  </button>
                  <button
                    style="padding: 8px 16px; background: #dc3545; color: white; border: none; border-radius: 30px;">
                    Cancel
                  </button>
                    </div>
                  </div>
                </div>
              </div>

          </div>

        <!-- Pagination Section -->

            <div class="pagination-wrapper">
              <nav aria-label="Page navigation">
                                <ul class="pagination justify-content-end mb-0">
                  {# Previous button #}
                  {% if page_obj.has_previous %}
                    <li>
                      <a href="?page={{ page_obj.previous_page_number }}" aria-label="Previous">
                        <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-left"></i></span>
                    </li>
                  {% endif %}
                
                  {# Always show first page #}
                  {% if page_obj.number > 3 %}
                    <li><a href="?page=1">1</a></li>
                    {% if page_obj.number > 4 %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                  {% endif %}
                
                  {# Show pages around current page #}
                  {% for num in page_obj.paginator.page_range %}
                    {% if num >= page_obj.number|add:'-2' and num <= page_obj.number|add:'2' %}
                      {% if num == page_obj.number %}
                        <li class="active"><span>{{ num }}</span></li>
                      {% else %}
                        <li><a href="?page={{ num }}">{{ num }}</a></li>
                      {% endif %}
                    {% endif %}
                  {% endfor %}
                
                  {# Show ellipsis and last page if needed #}
                  {% if page_obj.number < page_obj.paginator.num_pages|add:'-2' %}
                    {% if page_obj.number < page_obj.paginator.num_pages|add:'-3' %}
                      <li class="disabled"><span>…</span></li>
                    {% endif %}
                    <li><a href="?page={{ page_obj.paginator.num_pages }}">{{ page_obj.paginator.num_pages }}</a></li>
                  {% endif %}
                
                  {# Next button #}
                  {% if page_obj.has_next %}
                    <li>
                      <a href="?page={{ page_obj.next_page_number }}" aria-label="Next">
                        <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                      </a>
                    </li>
                  {% else %}
                    <li class="disabled">
                      <span aria-hidden="true"><i class="fa fa-chevron-right"></i></span>
                    </li>
                  {% endif %}
                </ul>
              </nav>
            </div>
          <!-- ...existing code... -->

        </div>
      </div>
    </div>
  </div>
  <!-- Image Slider Modal (popup) -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <h3>Visual Aid</h3>
    <div class="slider" id="slider">
      <div class="slides" id="slidesContainer">
        <div class="slide active">
          <img src="{% static 'assets/images/carousel/banner_1.jpg' %}" alt="Slide 1">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_2.jpg' %}" alt="Slide 2">
        </div>
        <div class="slide">
          <img src="{% static 'assets/images/carousel/banner_3.jpg' %}" alt="Slide 3">
        </div>
      </div>
      <button class="prev" id="prevBtn">&#10094;</button>
      <button class="next" id="nextBtn">&#10095;</button>
    </div>
  </div>
  <!-- Image Slider Modal -->
  <div id="imageSliderModal" class="image-slider-modal">
    <span id="closeImageSliderModal" class="modal-close-BQ">&times;</span>
    <div class="slider" id="slider">
      <button class="prev" id="prevBtn">&#8592;</button>
      <div class="slides"></div>
      <button class="next" id="nextBtn">&#8594;</button>
    </div>
  </div>
<!-- Hold Remark Modal -->
<div id="holdRemarkModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.18); z-index:20000; align-items:center; justify-content:center;">
  <div style="background:#fff; border-radius:10px; padding:28px 32px 18px 32px; min-width:320px; max-width:90vw; box-shadow:0 4px 24px rgba(0,0,0,0.18); position:relative;">
    <span id="closeHoldRemarkModal" style="position:absolute; top:8px; right:16px; font-size:22px; font-weight:bold; color:#d9534f; cursor:pointer;">&times;</span>
    <h5 style="margin-bottom:16px; color:#028084;">Row Hold Remark</h5>
    <textarea id="holdRemarkInput" maxlength="50" style="width:100%; height:60px; border:1px solid #ccc; border-radius:6px; padding:8px; font-size:15px; resize:none;" placeholder="Enter remark (max 50 chars)"></textarea>
    <div style="text-align:right; margin-top:10px;">
      <button id="saveHoldRemarkBtn" style="background:#007bff; color:#fff; border:none; border-radius:20px; padding:6px 18px; font-size:15px; cursor:pointer;">Save</button>
    </div>
    <div id="holdRemarkError" style="color:red; font-size:13px; min-height:18px; margin-top:6px;"></div>
  </div>
</div>
            
  {% block script %}

  
  <!-- Place this after your tray scan modal logic and after buildTableHTML is defined and used -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  // Show Edit icon after Tray Validate is clicked
  const validateBtn = document.getElementById("trayValidateBtn");
  const redoBtn = document.getElementById("trayQtyRedoBtn");
  const modal = document.getElementById("trayScanModal_DayPlanning");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");

  
  if (validateBtn) {
    validateBtn.addEventListener("click", function () {
      setTimeout(() => {
        const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
        if (topTrayRow) {
          const editIcon = topTrayRow.querySelector('.edit-tray-qty');
          if (editIcon) editIcon.style.display = 'inline-block';
        }
        if (redoBtn) redoBtn.style.display = 'inline-block';
      }, 100);
    });
  }



  // Redo icon click: reset qty, disable editing, disable Tray Validate
  if (redoBtn) {
    redoBtn.addEventListener('click', function () {
      const topTrayRow = document.querySelector('#trayScanDetails_DayPlanning tbody tr:first-child');
      if (topTrayRow) {
        const qtyInput = topTrayRow.querySelector('.tray-qty-input[data-top-tray="1"]');
        if (qtyInput) {
          qtyInput.value = qtyInput.getAttribute('data-initial');
          qtyInput.setAttribute('readonly', true);
        }


        // Hide Tray Validation Status column by rebuilding table without it
      if (modal && detailsDiv && modal.buildTableHTML) {
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }
       // ✅ Remove draft/cancel buttons and info message
      if (window.removeDraftCancelButtons) {
        window.removeDraftCancelButtons();
      }
      }
      if (validateBtn) {
        validateBtn.disabled = false;
        validateBtn.style.opacity = "1";
        validateBtn.style.cursor = "pointer";
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      if (redoBtn) redoBtn.style.display = 'none';
    });
  }

  // When qty is changed, re-enable Tray Validate
  document.addEventListener('input', function (e) {
    if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
      const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
      let currentQty = parseInt(e.target.value, 10) || 0;
      // Prevent increasing above original
      if (currentQty > originalQty) {
        e.target.value = originalQty;
      }
      // Prevent going below zero
      if (currentQty < 0) {
        e.target.value = 0;
      }
      // Enable Tray Validate as before
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.disabled = false;
        validateBtn.style.opacity = "1";
        validateBtn.style.cursor = "pointer";
      }
    }
  });

    document.addEventListener('click', function (e) {
    if (e.target.closest('.edit-tray-qty')) {
      const row = e.target.closest('tr');
      const qtyInput = row.querySelector('.tray-qty-input[data-top-tray="1"]');
      if (qtyInput) {
        qtyInput.removeAttribute('readonly');
        qtyInput.focus();
  
        // Add blur handler to return focus to validate input after editing
        qtyInput.addEventListener('blur', function handleBlur() {
          setTimeout(() => {
            // Only refocus if not clicking Edit icon again
            const active = document.activeElement;
            if (!active || !active.classList.contains('edit-tray-qty')) {
              const validateInput = document.getElementById("trayValidateInput");
              if (validateInput) validateInput.focus();
            }
          }, 100);
          // Remove this handler after it runs once
          qtyInput.removeEventListener('blur', handleBlur);
        });
      }
    }
  });

  
});
</script>

<!-- ✅ SCRIPT 1: Save IP Checkbox -->

<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  
  // ✅ HELPER FUNCTION: Get edited tray qty from modal
  function getEditedTrayQtyFromModal() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (!modal) {
      return null;
    }
    
    // Find the top tray input
    const editedTrayQtyInput = modal.querySelector('.tray-qty-input[data-top-tray="1"]');
    if (!editedTrayQtyInput) {
      return null;
    }
    
    const currentValue = editedTrayQtyInput.value.trim();
    const initialValue = editedTrayQtyInput.getAttribute('data-initial') || '';
    

    
    // Return current value regardless of whether it changed
    return currentValue || null;
  }

  // ✅ HELPER FUNCTION: Get CSRF token
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }

  // ✅ SAVE IP CHECKBOX HANDLER
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('save-ip-checkbox')) {
      const element = e.target;
      const row = element.closest('tr');
      
      let lotId = element.getAttribute('data-lot-id');
      if (!lotId) lotId = row.getAttribute('data-stock-lot-id');
      
      if (!lotId) {
        Swal.fire('Error', 'Lot ID not found', 'error');
        return;
      }
      
      // Get the calculated missing qty from the input
      const missingQtyInput = row.querySelector('.missing-qty-input');
      const missingQty = missingQtyInput ? missingQtyInput.value.trim() : '0';
      
      // ✅ FIXED: Get edited tray qty using helper function
      const editedTrayQty = getEditedTrayQtyFromModal();
      

      // Change icon to indicate processing
      if (element.tagName === 'I') {
        element.className = 'fa fa-spinner fa-spin';
      }
      
      // Disable element during processing
      element.style.pointerEvents = 'none';
      
      fetch('/inputscreening/save_ip_checkbox/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          lot_id: lotId,
          missing_qty: missingQty || '0',
          edited_tray_qty: editedTrayQty
        })
      })
      .then(res => res.json())
      .then(data => {
        if (data.success) {
          // Change to checked state
          if (element.tagName === 'I') {
            element.className = 'fa fa-check-square';
            element.style.color = '#28a745';
          }
          
          element.title = 'IP Checkbox saved';
          
          Swal.fire({
            icon: 'success',
            title: 'Saved successfully!',
            text: `Missing Qty: ${missingQty}, Edited Tray Qty: ${editedTrayQty || 'None'}`,
            timer: 2000,
            showConfirmButton: false
          });
          
          // Update row to show verification completed
          updateRowAfterIPSave(row, lotId, missingQty);
          
          // Reload page after a short delay
          setTimeout(() => {
            window.location.reload();
          }, 1500);
          
        } else {
          Swal.fire('Error', data.error || 'Save failed', 'error');
          // Reset icon and enable element
          if (element.tagName === 'I') {
            element.className = 'fa fa-square-o';
          }
          element.style.pointerEvents = 'auto';
        }
      })
      .catch(error => {
        Swal.fire('Error', 'Network error', 'error');
        // Reset icon and enable element
        if (element.tagName === 'I') {
          element.className = 'fa fa-square-o';
        }
        element.style.pointerEvents = 'auto';
      });
    }
  });

  // ✅ HELPER FUNCTION: Update row after IP save
  function updateRowAfterIPSave(row, lotId, missingQty) {
    // Update main IP checkbox
    const mainIpCheckbox = row.querySelector('.ip-checkbox');
    if (mainIpCheckbox) {
      mainIpCheckbox.checked = true;
      mainIpCheckbox.disabled = true;
    }
    
    // Update missing qty input
    const missingQtyInput = row.querySelector('.missing-qty-input');
    if (missingQtyInput) {
      missingQtyInput.disabled = true;
    }
    
    // Update physical qty
    const physicalQtyInput = row.querySelector('.physical-qty-input');
    const lotQtySpan = row.querySelector('.lot-qty');
    if (physicalQtyInput && lotQtySpan && missingQty) {
      const totalQty = parseInt(lotQtySpan.textContent.trim(), 10);
      const newPhysicalQty = totalQty - parseInt(missingQty);
      physicalQtyInput.value = newPhysicalQty;
    }
    
    // Update process status Q icon
    const processIcons = row.querySelectorAll('.d-flex > div');
    if (processIcons.length > 0) {
      processIcons[0].style.backgroundColor = '#0c8249';
    }
  }

  // ✅ Make helper functions available globally
  window.getEditedTrayQtyFromModal = getEditedTrayQtyFromModal;
  window.getCookie = getCookie;
});
</script>

<!-- ✅ SCRIPT 2: Modal Opening and Table Building -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach(function(link) {
    link.addEventListener('click', async function (e) {
      e.preventDefault();

      // Get modal elements
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
      modal.dataset.batchId = link.getAttribute('data-batch-id');

      // Get data attributes
      const batchId = link.getAttribute('data-batch-id');
      const stockLotId = link.getAttribute('data-stock-lot-id');
      const modelNo = link.getAttribute('data-model-no');
      const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
      const trayCapacity = link.getAttribute('data-tray-capacity') || "";
      const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';
      
      let trayQtyList = [];
      try {
        trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
      } catch (e) {
        trayQtyList = [];
      }

      // Set model number in modal
      if (modalModelNo && modelNo) {
        modalModelNo.textContent = modelNo;
      }

      // Set model image
      const modalUserImg = modal.querySelector('.user-profile img');
      const modelImage = link.getAttribute('data-model-image');
      if (modalUserImg) {
        if (modelImage) {
          modalUserImg.src = modelImage;
        } else {
          modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
        }
      }

      // Show/Hide validation buttons based on verification status
      const trayValidateSection = document.getElementById("trayValidateSection");
      const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");

      if (isQtyVerified) {
        if (trayValidateSection) trayValidateSection.style.display = "none";
        if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
      } else {
        if (trayValidateSection) trayValidateSection.style.display = "flex";
        if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
      }

      // Fetch tray data with proper top tray handling using API
      let traysData = [];
      try {
        const resp = await fetch(`/inputscreening/ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
        const result = await resp.json();
        if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
          traysData = result.trays;
        }
      } catch (e) {
      }

      // Fetch existing verification status
      let verificationData = {};
      try {
        const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
        const verifyResult = await verifyResp.json();
        if (verifyResult.success) {
          verificationData = verifyResult.verification_data;
        }
      } catch (e) {
      }

      // ✅ TABLE BUILDING FUNCTION
      function buildTableHTML(showValidationColumn = false) {
        let html = `
          <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
            <thead>
              <tr>
                <th style="width:50px;">S.no</th>
                <th>Tray ID</th>
                <th>Tray Qty</th>
                ${showValidationColumn && !isQtyVerified ? '<th>Tray Validation Status</th>' : ''}
              </tr>
            </thead>
            <tbody>
        `;
        
        // If we have trays data from API, use it directly
        if (traysData && traysData.length > 0) {
          traysData.forEach((tray, index) => {
            const isTopTray = tray.is_top_tray || index === 0;
            const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
            const position = index + 1;

            // Check verification status
            const verification = verificationData[position];
            const isVerifiedByUser = verification ? verification.is_verified : false;
            const isVerifiedInDB = tray.IP_tray_verified || false;
            const isVerified = isVerifiedByUser || isVerifiedInDB;
            
            const verificationStatus = verification ? verification.verification_status : null;
            const verifiedTrayId = verification ? verification.tray_id : '';

            // Set input properties based on verification status
            let inputValue, inputStyle, verificationIndicator;

            if (isVerified) {
              inputValue = verifiedTrayId || tray.tray_id || '';
              inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
              verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
            } else {
              inputValue = tray.tray_id || '';
              inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
              verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
            }

            html += `
              <tr>
                <td>${displaySNo}</td>
                <td>
                  <input type="text" 
                         class="form-control" 
                         value="${inputValue}" 
                         readonly 
                         style="${inputStyle}"
                         data-position="${position}" />
                  ${verificationIndicator}
                </td>
                <td style="position:relative; white-space:nowrap;">
                  <span style="display:inline-flex; align-items:center;">
                    <input type="number" 
                           class="form-control tray-qty-input" 
                           value="${tray.tray_quantity || ''}" 
                           readonly 
                           style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                           data-initial="${tray.tray_quantity || ''}"
                           ${isTopTray ? 'data-top-tray="1"' : ''} 
                    />
                   
                  </span>
                </td>
                ${showValidationColumn && !isQtyVerified ? `
                  <td>
                    <div class="validation-status">
                      <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                        <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                      </div>
                      <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                        <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                      </div>
                    </div>
                  </td>
                ` : ''}
              </tr>
            `;
          });
        } else {
          // Fallback: Use the old method if API data is not available
          let totalRows = noOfTrays;
          for (let i = 0; i < totalRows; i++) {
            const position = i + 1;
            const verification = verificationData[position];
            const isVerified = verification ? verification.is_verified : false;
            const verificationStatus = verification ? verification.verification_status : null;
            const verifiedTrayId = verification ? verification.tray_id : '';
            const trayQty = trayQtyList[i] || trayCapacity;
            
            let inputValue, inputStyle, verificationIndicator;
            
            if (isVerified) {
              inputValue = verifiedTrayId;
              inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
              verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
            } else {
              inputValue = '';
              inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
              verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
            }
            
            html += `
              <tr>
                <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                <td>
                  <input type="text" 
                         class="form-control" 
                         value="${inputValue}" 
                         readonly 
                         style="${inputStyle}"
                         data-position="${position}" />
                  ${verificationIndicator}
                </td>
                <td>
                  <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                </td>
                ${showValidationColumn && !isQtyVerified ? `
                  <td>
                    <div class="validation-status">
                      <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                        <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                      </div>
                      <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                        <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                      </div>
                    </div>
                  </td>
                ` : ''}
              </tr>
            `;
          }
        }
        
        html += `
            </tbody>
          </table>
        `;
        return html;
      }



      // Initially show table
      detailsDiv.innerHTML = buildTableHTML(false);

      // Store data in modal for later use
      modal.buildTableHTML = buildTableHTML;
      modal.traysData = traysData;
      modal.verificationData = verificationData;
      modal.noOfTrays = noOfTrays;
      modal.trayQtyList = trayQtyList;
      modal.trayCapacity = trayCapacity;
      modal.isQtyVerified = isQtyVerified;
      modal.stockLotId = stockLotId;

      // Show the modal
      if (modal) modal.style.display = "block";
      modal.classList.add("open");

      // Check verification status after modal opens
      setTimeout(() => {
        if (!modal.isQtyVerified) {
          checkVerificationStatusAndShowButtons();
        } else {
          removeDraftCancelButtons();
        }
      }, 200);
    });
  });

  // ✅ HELPER FUNCTIONS for modal operations
  function getCurrentBatchId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.dataset.batchId) return modal.dataset.batchId;
    const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-batch-id]');
    return lastBtn ? lastBtn.getAttribute('data-batch-id') : '';
  }

  function getCurrentLotId() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal && modal.stockLotId) return modal.stockLotId;
    const lastBtn = document.querySelector('.tray-scan-btn-DayPlanning-view[data-stock-lot-id]');
    return lastBtn ? lastBtn.getAttribute('data-stock-lot-id') : '';
  }

  // ✅ Make helper functions available globally
  window.getCurrentBatchId = getCurrentBatchId;
  window.getCurrentLotId = getCurrentLotId;
});
</script>

<!-- ✅ SCRIPT 3: Tray Validation and Verification Status -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  
  function showError(message) {
    const errorMessage = document.getElementById("trayErrorMessage");
    const errorText = document.getElementById("trayErrorText");
    if (errorMessage && errorText) {
      errorText.textContent = message;
      errorMessage.style.display = "block";
      setTimeout(() => {
        errorMessage.style.display = "none";
      }, 5000);
    }
  }

  function hideError() {
    const errorMessage = document.getElementById("trayErrorMessage");
    if (errorMessage) {
      errorMessage.style.display = "none";
    }
  }

  // ✅ TRAY VALIDATION INPUT HANDLER
  const validateInput = document.getElementById("trayValidateInput");
  const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");

  if (validateInput && detailsDiv) {
    validateInput.addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        const trayId = validateInput.value.trim();
        if (!trayId) return;

        // Check if this tray ID is already verified
        const alreadyVerified = Array.from(detailsDiv.querySelectorAll("tbody tr")).some(row => {
          const input = row.querySelector('input[type="text"]');
          const verificationIndicator = row.querySelector('small');
          
          return input && 
                 input.value.trim() === trayId && 
                 verificationIndicator && 
                 verificationIndicator.textContent.includes('✓ Verified');
        });

        if (alreadyVerified) {
          showError(`Tray ID "${trayId}" is already verified. Cannot scan again.`);
          validateInput.value = "";
          return;
        }

        const batchId = window.getCurrentBatchId();
        const lotId = window.getCurrentLotId();
        if (!batchId || !lotId) return;

        hideError();

        // Find the row where trayId matches and is not yet verified
        const rows = detailsDiv.querySelectorAll("tbody tr");
        let targetRow = null;
        let position = null;

        rows.forEach((row, index) => {
          if (!targetRow) {
            const trayIdInput = row.querySelector('input[type="text"]');
            const verificationIndicator = row.querySelector('small');
            
            if (
              trayIdInput &&
              trayIdInput.value.trim() === trayId &&
              verificationIndicator &&
              !verificationIndicator.textContent.includes('✓ Verified')
            ) {
              targetRow = row;
              position = parseInt(trayIdInput.getAttribute('data-position')) || (index + 1);
            }
          }
        });

        if (!targetRow) {
          showError(`Tray ID "${trayId}" is not expected in this position or already verified.`);
          validateInput.value = "";
          return;
        }

        // Send validation request
        fetch("/inputscreening/ip_tray_validate/", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": window.getCookie('csrftoken')
          },
          body: JSON.stringify({
            batch_id: batchId,
            tray_id: trayId,
            tray_position: position,
            lot_id: lotId
          })
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            const trayIdInput = targetRow.querySelector('input[type="text"]');
            const statusCell = targetRow.querySelector("td:last-child");
            
            // Fill the tray ID and make it readonly
            if (trayIdInput) {
              trayIdInput.value = trayId;
              trayIdInput.setAttribute('readonly', true);
              trayIdInput.style.backgroundColor = '#f5f5f5';
              trayIdInput.style.borderColor = data.exists ? '#28a745' : '#dc3545';
              trayIdInput.style.color = data.exists ? '#155724' : '#721c24';

              // Update verification indicator text
              const existingIndicator = trayIdInput.parentElement.querySelector('small');
              if (existingIndicator) {
                existingIndicator.style.color = data.exists ? '#28a745' : '#dc3545';
                existingIndicator.style.fontWeight = 'bold';
                existingIndicator.textContent = data.exists ? '✓ Verified' : '✗ Failed';
              }
            }

            if (statusCell) {
              if (data.exists) {
                // Pass validation
                statusCell.innerHTML = `
                  <div class="validation-status">
                    <div class="status-icon fail inactive">
                      <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                    </div>
                    <div class="status-icon pass active">
                      <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                    </div>
                  </div>
                `;
              } else {
                // Fail validation
                statusCell.innerHTML = `
                  <div class="validation-status">
                    <div class="status-icon fail active">
                      <img src="{% static 'assets/icons/fail.png' %}" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                    </div>
                    <div class="status-icon pass inactive">
                      <img src="{% static 'assets/icons/pass.png' %}" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                    </div>
                  </div>
                `;
              }
            }
          }

          // Clear and focus input for next scan
          validateInput.value = "";
          validateInput.focus();

          // Check verification status after each scan
          setTimeout(() => {
            checkVerificationStatusAndShowButtons();
          }, 100);
        })
        .catch(error => {
          showError('An error occurred while validating the tray ID.');
          validateInput.value = "";
          validateInput.focus();
        });
      }
    });
  }

  // ✅ CHECK VERIFICATION STATUS AND SHOW BUTTONS
  function checkVerificationStatusAndShowButtons() {
    const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
    const rows = detailsDiv.querySelectorAll("tbody tr");
    if (rows.length === 0) {
      return;
    }

    // Check if quantity is already verified
    const modal = document.getElementById("trayScanModal_DayPlanning");
    const isQtyAlreadyVerified = modal && modal.isQtyVerified;
    
    if (isQtyAlreadyVerified) {
      removeDraftCancelButtons();
      return;
    }

    let totalTrays = 0;
    let verifiedTrays = 0;
    let unverifiedTrays = 0;
    let filledTrays = 0;


    rows.forEach((row, index) => {
      const trayIdInput = row.querySelector('input[type="text"]');
      
      if (trayIdInput) {
        totalTrays++;
        const trayId = trayIdInput.value.trim();
        
        if (trayId) {
          filledTrays++;
          
          // Check for verification indicator in the Tray ID column
          const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
          const verificationText = hasVerificationIndicator ? hasVerificationIndicator.textContent : '';
          
          // Check for validation status icons if validation column exists
          const statusCell = row.querySelector("td:last-child");
          const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
          
          // Additional check: readonly status with verification background
          const isReadonlyVerified = trayIdInput.hasAttribute('readonly') && 
                                    (trayIdInput.style.backgroundColor.includes('#f5f5f5') || 
                                     trayIdInput.style.borderColor.includes('#28a745'));
          
          // Row is verified if any verification method returns true
          const isVerified = (hasVerificationIndicator && verificationText.includes('✓')) || 
                            hasPassIcon || 
                            isReadonlyVerified;
          
          if (isVerified) {
            verifiedTrays++;
          } else {
            unverifiedTrays++;
          }
        }
      }
    });

    // Show buttons logic
    if (totalTrays > 0) {
      if (verifiedTrays === totalTrays && filledTrays > 0) {
        removeDraftCancelButtons();
        autoTriggerCheckboxSave();
      } else if (verifiedTrays > 0 && unverifiedTrays > 0 && !draftButtonsShown) {
        showDraftCancelButtons();
      } else if (filledTrays === 0) {
        removeDraftCancelButtons();
      }
    }
  }

  // ✅ Make function available globally
  window.checkVerificationStatusAndShowButtons = checkVerificationStatusAndShowButtons;
});
</script>

<!-- ✅ SCRIPT 4: Draft Save and Auto-trigger Functionality -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  
  let draftButtonsShown = false;

  // ✅ CALCULATE TRAY QUANTITIES
  function calculateTrayQuantities() {
    const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
    
    let totalLotQty = 0;
    let verifiedQty = 0;
    let unverifiedQty = 0;
    
    const rows = detailsDiv.querySelectorAll("tbody tr");
    
    
    rows.forEach((row, index) => {
      const trayQtyInput = row.querySelector('input[type="number"]');
      const trayIdInput = row.querySelector('input[type="text"]');
      
      if (trayQtyInput && trayIdInput) {
        const trayQty = parseInt(trayQtyInput.value) || 0;
        totalLotQty += trayQty;
        
        // Check multiple ways to determine if row is verified
        let isVerified = false;
        
        // Method 1: Check for verification indicator (✓ Verified text)
        const hasVerificationIndicator = trayIdInput.parentElement.querySelector('small');
        if (hasVerificationIndicator && hasVerificationIndicator.textContent.includes('✓')) {
          isVerified = true;
        }
        
        // Method 2: Check for validation status icons
        if (!isVerified) {
          const statusCell = row.querySelector("td:last-child");
          const hasPassIcon = statusCell && statusCell.querySelector('.status-icon.pass.active');
          if (hasPassIcon) {
            isVerified = true;
          }
        }
        
        // Method 3: Check if tray ID input is readonly and has value
        if (!isVerified && trayIdInput.hasAttribute('readonly') && trayIdInput.value.trim()) {
          const inputStyle = trayIdInput.style.backgroundColor;
          if (inputStyle.includes('#f5f5f5')) {
            isVerified = true;
          }
        }
        
        // Add to appropriate counter
        if (isVerified) {
          verifiedQty += trayQty;
        } else {
          unverifiedQty += trayQty;
        }
      }
    });
    

    return {
      totalLotQty,
      verifiedQty,
      unverifiedQty
    };
  }

  // ✅ HANDLE DRAFT SAVE
  function handleDraftSave() {
    const lotId = window.getCurrentLotId();
    if (!lotId) {
      showError('Lot ID not found');
      return;
    }

    const { totalLotQty, unverifiedQty, verifiedQty } = calculateTrayQuantities();
    const editedTrayQty = window.getEditedTrayQtyFromModal();
    


    const draftBtn = document.getElementById('trayDraftBtn');
    if (draftBtn) {
      draftBtn.disabled = true;
      draftBtn.textContent = 'Saving...';
    }

    showSuccessMessage('Saving as draft...', '#007bff');

    fetch('/inputscreening/ip_save_tray_draft/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': window.getCookie('csrftoken')
      },
      body: JSON.stringify({
        lot_id: lotId,
        total_lot_qty: totalLotQty,
        missing_qty: unverifiedQty,
        physical_qty: totalLotQty - unverifiedQty,
        edited_tray_qty: editedTrayQty
      })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        showSuccessMessage('✅ Saved as draft! Missing qty and physical qty updated.', '#28a745');
        updateMainTableRowForDraftWithQuantities(lotId, unverifiedQty, totalLotQty - unverifiedQty);
        setTimeout(() => {
          const modal = document.getElementById("trayScanModal_DayPlanning");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
          window.location.reload();
        }, 2000);
      } else {
        showSuccessMessage('❌ Draft save failed: ' + (data.error || 'Unknown error'), '#dc3545');
        if (draftBtn) {
          draftBtn.disabled = false;
          draftBtn.textContent = 'Save as Draft';
        }
      }
    })
    .catch(error => {
      showSuccessMessage('❌ Draft save network error', '#dc3545');
      if (draftBtn) {
        draftBtn.disabled = false;
        draftBtn.textContent = 'Save as Draft';
      }
    });
  }

  // ✅ AUTO-TRIGGER CHECKBOX SAVE
  function autoTriggerCheckboxSave() {
    const lotId = window.getCurrentLotId();
    if (!lotId) {
      return;
    }

    const { totalLotQty, unverifiedQty, verifiedQty } = calculateTrayQuantities();
    const missingQty = unverifiedQty;
    const physicalQty = totalLotQty - unverifiedQty;
    const editedTrayQty = window.getEditedTrayQtyFromModal();

    showSuccessMessage('All trays verified! Auto-saving checkbox...', '#007bff');

    fetch('/inputscreening/save_ip_checkbox/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': window.getCookie('csrftoken')
      },
      body: JSON.stringify({
        lot_id: lotId,
        missing_qty: missingQty || '0',
        edited_tray_qty: editedTrayQty
      })
    })
    .then(res => res.json())
    .then(data => {
      if (data.success) {
        showSuccessMessage('✅ Checkbox automatically saved! All trays verified.', '#28a745');
        updateMainTableRowStatus(lotId, missingQty, physicalQty);
        setTimeout(() => {
          const modal = document.getElementById("trayScanModal_DayPlanning");
          if (modal) {
            modal.classList.remove("open");
            modal.style.display = "none";
          }
          window.location.reload();
        }, 2000);
      } else {
        showSuccessMessage('❌ Auto-save failed: ' + (data.error || 'Unknown error'), '#dc3545');
      }
    })
    .catch(error => {
      showSuccessMessage('❌ Auto-save network error', '#dc3545');
    });
  }

  // ✅ SHOW DRAFT/CANCEL BUTTONS
  function showDraftCancelButtons() {
    if (draftButtonsShown) {
      return;
    }

    removeDraftCancelButtons();

    const infoMsg = document.createElement('div');
    infoMsg.id = 'draftInfoMessage';
    infoMsg.style.cssText = `
      background: #fff3cd;
      border: 1px solid #ffeaa7;
      color: #856404;
      padding: 12px 16px;
      border-radius: 8px;
      margin: 15px 0;
      font-size: 14px;
      text-align: center;
    `;
    infoMsg.innerHTML = `
      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
      Some tray IDs are not verified. You can save as draft to continue later or cancel to return.
    `;

    const buttonContainer = document.createElement('div');
    buttonContainer.id = 'draftCancelButtons';
    buttonContainer.style.cssText = `
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
      border: 1px solid #dee2e6;
    `;

    const draftBtn = document.createElement('button');
    draftBtn.id = 'trayDraftBtn';
    draftBtn.textContent = 'Save as Draft';
    draftBtn.style.cssText = `
      padding: 10px 20px;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    `;

    const cancelBtn = document.createElement('button');
    cancelBtn.id = 'trayCancelBtn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.style.cssText = `
      padding: 10px 20px;
      background: #6c757d;
      color: white;
      border: none;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
    `;

    draftBtn.onmouseover = () => draftBtn.style.background = '#0056b3';
    draftBtn.onmouseout = () => draftBtn.style.background = '#007bff';
    cancelBtn.onmouseover = () => cancelBtn.style.background = '#545b62';
    cancelBtn.onmouseout = () => cancelBtn.style.background = '#6c757d';

    draftBtn.onclick = handleDraftSave;
    cancelBtn.onclick = handleCancel;

    buttonContainer.appendChild(draftBtn);
    buttonContainer.appendChild(cancelBtn);

    const modal = document.getElementById("trayScanModal_DayPlanning");
    const modalContent = modal.querySelector('.tray-scan-modal-DayPlanning-content');
    if (modalContent) {
      modalContent.appendChild(infoMsg);
      modalContent.appendChild(buttonContainer);
    }

    draftButtonsShown = true;
  }

  // ✅ REMOVE DRAFT/CANCEL BUTTONS
  function removeDraftCancelButtons() {
    const existingInfoMsg = document.getElementById('draftInfoMessage');
    if (existingInfoMsg) {
      existingInfoMsg.remove();
    }

    const existingButtons = document.getElementById('draftCancelButtons');
    if (existingButtons) {
      existingButtons.remove();
    }

    draftButtonsShown = false;
  }

  // ✅ HANDLE CANCEL
  function handleCancel() {
    const modal = document.getElementById("trayScanModal_DayPlanning");
    if (modal) {
      modal.classList.remove("open");
      modal.style.display = "none";
    }
  }

  // ✅ UPDATE MAIN TABLE ROW FOR DRAFT WITH QUANTITIES
  function updateMainTableRowForDraftWithQuantities(lotId, missingQty, physicalQty) {
    try {
      const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
      if (!mainTableRow) {
        return;
      }

      const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
      if (missingQtyInput) {
        missingQtyInput.value = missingQty;
        missingQtyInput.style.backgroundColor = '#fff3cd';
        missingQtyInput.style.borderColor = '#ffc107';
      }

      const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
      if (physicalQtyInput) {
        physicalQtyInput.value = physicalQty;
        physicalQtyInput.style.backgroundColor = '#fff3cd';
        physicalQtyInput.style.borderColor = '#ffc107';
        physicalQtyInput.setAttribute('title', 'This quantity was calculated from draft');
      }



      const lotStatusCell = mainTableRow.cells[17];
      if (lotStatusCell) {
        lotStatusCell.innerHTML = `
          <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
              style="border: 2px solid #4997ac; background-color: #d1f2f3; color: #03425d; 
                     font-size: 13px; white-space: nowrap; 
                     padding-top: 0.5rem; padding-bottom: 0.5rem;">
            Draft (Qty Calculated)
          </div>
        `;
      }

    } catch (error) {
    }
  }

  // ✅ UPDATE MAIN TABLE ROW STATUS
  function updateMainTableRowStatus(lotId, missingQty, physicalQty) {
    try {
      const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${lotId}"]`);
      if (!mainTableRow) {
        return;
      }

      const missingQtyInput = mainTableRow.querySelector('.missing-qty-input');
      if (missingQtyInput) {
        missingQtyInput.value = missingQty;
        missingQtyInput.disabled = true;
        if (missingQty === 0) {
          missingQtyInput.style.backgroundColor = '#d4edda';
          missingQtyInput.style.borderColor = '#28a745';
        } else {
          missingQtyInput.style.backgroundColor = '#fff3cd';
          missingQtyInput.style.borderColor = '#ffc107';
        }
      }

      const physicalQtyInput = mainTableRow.querySelector('.physical-qty-input');
      if (physicalQtyInput) {
        physicalQtyInput.value = physicalQty;
        physicalQtyInput.style.backgroundColor = '#d4edda';
        physicalQtyInput.style.borderColor = '#28a745';
        physicalQtyInput.setAttribute('title', 'Quantity verified through tray scan');
      }

      const checkbox = mainTableRow.querySelector('.ip-checkbox');
      if (checkbox) {
        checkbox.checked = true;
        checkbox.disabled = true;
      }

      const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
      if (processIcons.length > 0) {
        processIcons[0].style.backgroundColor = '#0c8249';
      }

      const saveIpCheckbox = mainTableRow.querySelector('.save-ip-checkbox');
      if (saveIpCheckbox) {
        saveIpCheckbox.style.display = 'none';
      }


    } catch (error) {
    }
  }

  // ✅ SHOW SUCCESS MESSAGE
  function showSuccessMessage(message, color = '#28a745') {
    const existingMsg = document.getElementById('auto-save-message');
    if (existingMsg) {
      existingMsg.remove();
    }

    const messageDiv = document.createElement('div');
    messageDiv.id = 'auto-save-message';
    messageDiv.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: ${color};
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 10002;
      font-weight: 500;
      transform: translateX(400px);
      transition: transform 0.3s ease;
      max-width: 300px;
      word-wrap: break-word;
    `;
    messageDiv.style.zIndex = "1000001"; // Higher than modal

    messageDiv.textContent = message;
    document.body.appendChild(messageDiv);

    setTimeout(() => {
      messageDiv.style.transform = 'translateX(0)';
    }, 100);

    setTimeout(() => {
      messageDiv.style.transform = 'translateX(400px)';
      setTimeout(() => {
        if (messageDiv.parentNode) {
          messageDiv.parentNode.removeChild(messageDiv);
        }
      }, 300);
    }, 4000);
  }

  // ✅ Make functions available globally
  window.showDraftCancelButtons = showDraftCancelButtons;
  window.removeDraftCancelButtons = removeDraftCancelButtons;
  window.autoTriggerCheckboxSave = autoTriggerCheckboxSave;
  window.handleDraftSave = handleDraftSave;
  window.draftButtonsShown = draftButtonsShown;
});
</script>

<!-- ✅ SCRIPT 5: Button Handlers and Modal Controls -->
<script nonce="{{ csp_nonce }}">
document.addEventListener("DOMContentLoaded", function () {
  
  // ✅ TRAY VALIDATE BUTTON HANDLER
  const validateBtn = document.getElementById("trayValidateBtn");
  const validateInput = document.getElementById("trayValidateInput");
  const errorMessage = document.getElementById("trayErrorMessage");

  if (validateBtn && validateInput) {
    validateBtn.addEventListener("click", function () {
      if (validateBtn.disabled) return;

      validateInput.value = "";
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Change button to active state
      validateBtn.style.background = "#e8f5e8";
      validateBtn.style.borderColor = "#4caf50";
      validateBtn.style.color = "#2e7d32";
      
      // Add the validation column to the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      if (modal && detailsDiv && modal.buildTableHTML) {
        detailsDiv.innerHTML = modal.buildTableHTML(true);
      }
      
      validateInput.focus();
    });
  }

  // ✅ REDO BUTTON HANDLER
  const redoBtn = document.getElementById("trayQtyRedoBtn");
  if (redoBtn && validateInput) {
    redoBtn.addEventListener("click", function () {
      validateInput.value = "";
      validateInput.blur();
      
      if (errorMessage) {
        errorMessage.style.display = "none";
      }
      
      // Reset button to normal state
      if (validateBtn) {
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
      
      // Remove the validation column from the table
      const modal = document.getElementById("trayScanModal_DayPlanning");
      const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
      if (modal && detailsDiv && modal.buildTableHTML) {
        detailsDiv.innerHTML = modal.buildTableHTML(false);
      }

      // Reset tray verification for this lot
      const lotId = window.getCurrentLotId();
      if (lotId) {
        fetch('/inputscreening/reset_tray_verification_for_lot/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': window.getCookie('csrftoken')
          },
          body: JSON.stringify({ lot_id: lotId })
        })
        .then(res => res.json())
        .then(data => {
          // Silent operation
        })
        .catch(() => {
          // Silent operation
        });
      }

      redoBtn.focus();
    });
  }


  // ✅ QTY INPUT CHANGE HANDLER
  document.addEventListener('input', function (e) {
    if (e.target.classList.contains('tray-qty-input') && e.target.dataset.topTray === "1") {
      const originalQty = parseInt(e.target.getAttribute('data-initial'), 10) || 0;
      let currentQty = parseInt(e.target.value, 10) || 0;
      
      // Prevent increasing above original
      if (currentQty > originalQty) {
        e.target.value = originalQty;
      }
      // Prevent going below zero
      if (currentQty < 0) {
        e.target.value = 0;
      }
      
      // Enable Tray Validate button
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.disabled = false;
        validateBtn.style.opacity = "1";
        validateBtn.style.cursor = "pointer";
      }
    }
  });

  // ✅ MODAL CLOSE HANDLER
  const closeBtn = document.getElementById("closeTrayScanModal_DayPlanning");
  if (closeBtn) {
    closeBtn.addEventListener("click", function () {
      window.removeDraftCancelButtons();
      window.draftButtonsShown = false;
      
      const modal = document.getElementById("trayScanModal_DayPlanning");
      if (modal) {
        modal.classList.remove("open");
        modal.style.display = "none";
      }
      
      const validateBtn = document.getElementById("trayValidateBtn");
      if (validateBtn) {
        validateBtn.disabled = false;
        validateBtn.style.opacity = "1";
        validateBtn.style.cursor = "pointer";
        validateBtn.style.background = "#f5faff";
        validateBtn.style.borderColor = "#023E4DCC";
        validateBtn.style.color = "#023E4DCC";
      }
    });
  }
});
</script>

<!--Accept functionality-->
<script nonce="{{csp_nonce}}">
document.addEventListener("DOMContentLoaded", function () {
  // Use event delegation to handle dynamically created buttons
  document.addEventListener('click', function(e) {
    // Check if the clicked element is an Accept button
    if (e.target.closest('.btn-twitter')) {
      const acceptBtn = e.target.closest('.btn-twitter');
      
      // Skip if button is disabled
      if (acceptBtn.disabled) return;
      
      const row = acceptBtn.closest('tr');
      if (!row) return;
      
      // Try to get lot ID from multiple sources
      let lotId = acceptBtn.getAttribute('data-lot-id');
      if (!lotId) {
        const checkbox = row.querySelector('.ip-checkbox');
        lotId = checkbox ? checkbox.getAttribute('data-lot-id') : null;
      }
      if (!lotId) {
        lotId = row.getAttribute('data-stock-lot-id');
      }
      
      if (!lotId) {
        Swal.fire('Error', 'Lot ID not found', 'error');
        return;
      }
      
      // Show confirmation dialog before proceeding
      Swal.fire({
        title: 'Lot Accept',
        text: 'Are you sure you want to accept this lot?',
        icon: 'question',
        showCancelButton: true,
        confirmButtonColor: '#28a745',
        cancelButtonColor: '#6c757d',
        confirmButtonText: 'Yes, Accept',
        cancelButtonText: 'Cancel',
        reverseButtons: true
      }).then((result) => {
        if (result.isConfirmed) {
          // User confirmed, proceed with acceptance
          
          // Disable button during processing
          acceptBtn.disabled = true;
          
          fetch('/inputscreening/is_accepted_form/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({ stock_lot_id: lotId })
      })
      .then(res => {
        if (res.redirected) {
          window.location.href = res.url; // handle Django redirect
          return;
        }
        return res.json();
      })
      .then(data => {
        if (data && data.success) {
          Swal.fire({
            icon: 'success',
            title: 'Accepted successfully!',
            showConfirmButton: false,
            timer: 1200
          }).then(() => {
            // Update UI elements silently instead of reloading page
            window.location.reload(); // Reload to reset state
          });
        } else if (data && data.error) {
          Swal.fire('Error', data.error, 'error');
          // Re-enable button on error
          acceptBtn.disabled = false;
        }
      })
      .catch((error) => {
        Swal.fire('Error', 'Network error', 'error');
        // Re-enable button on error
        acceptBtn.disabled = false;
      });
        }
      });
    }
  });
  
  // Helper function for CSRF token (if not already defined)
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
});
</script>

<script nonce="{{ csp_nonce }}">
      document.addEventListener("DOMContentLoaded", function () {
      
        const cancelBtn = document.getElementById("trayScanCancelBtn");
        if (cancelBtn) {
          cancelBtn.addEventListener("click", function () {
            const modal = document.getElementById("trayScanModal_BQ");
            if (modal) modal.classList.remove("open");
          });
        }
      
         // DELETE BUTTON HANDLER
    document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
        btn.addEventListener('click', function(e) {
          e.preventDefault();
          const row = btn.closest('tr');
          if (!row) return;
          const batchId = btn.getAttribute('data-batch-id');
          const stockLotId = btn.getAttribute('data-stock-lot-id');
          if (!batchId || !stockLotId) {
            Swal.fire('Error', 'Batch ID or Stock Lot ID not found!', 'error');
            return;
          }
          Swal.fire({
            title: 'Are you sure?',
            text: 'Do you really want to delete this batch?',
            icon: 'warning',
            showCancelButton: true,
            confirmButtonColor: '#d33',
            cancelButtonColor: '#3085d6',
            confirmButtonText: 'Yes, delete it!',
            cancelButtonText: 'Cancel'
          }).then((result) => {
            if (result.isConfirmed) {
              fetch('/inputscreening/ip_delete_batch/', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({ batch_id: batchId, stock_lot_id: stockLotId })
              })
              .then(res => res.json())
              .then(data => {
                if (data.success) {
                  row.remove();
                  Swal.fire({
                    icon: 'success',
                    title: 'Deleted!',
                    text: 'Batch has been deleted.',
                    timer: 1200,
                    showConfirmButton: false
                  });                  
                } else {
                  Swal.fire('Error', data.error || 'Delete failed', 'error');
                }
              });
            }
          });
        });
      });


// Helper function to show error notification
function showErrorNotification(message) {
  // Create or get existing notification element
  let notification = document.getElementById('error-notification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'error-notification';
    notification.style.cssText = `
      position: fixed;
      top: 20px;
      right: 20px;
      background: #dc3545;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(220,53,69,0.15);
      z-index: 10001;
      font-weight: 500;
      transform: translateX(400px);
      transition: transform 0.3s ease;
    `;
    document.body.appendChild(notification);
  }
  
  notification.textContent = message;
  
  // Show notification
  setTimeout(() => {
    notification.style.transform = 'translateX(0)';
  }, 100);
  
  // Hide notification after 4 seconds (longer for errors)
  setTimeout(() => {
    notification.style.transform = 'translateX(400px)';
  }, 4000);
}

const table = document.getElementById("order-listing");
        if (!table) {
          return;
        }
      
        const headers = table.querySelectorAll("thead th");
        const tbody = table.querySelector("tbody");
      
        let sortDirection = {};
      
        headers.forEach((header, index) => {
          header.style.cursor = "pointer";
      
          header.addEventListener("click", function () {
            const rows = Array.from(tbody.querySelectorAll("tr"));
            const dir = sortDirection[index] === "asc" ? "desc" : "asc";
            sortDirection[index] = dir;
      
            rows.sort((a, b) => {
              const cellA = a.children[index].textContent.trim();
              const cellB = b.children[index].textContent.trim();
              const valA = isNaN(cellA) ? cellA : parseFloat(cellA);
              const valB = isNaN(cellB) ? cellB : parseFloat(cellB);
      
              if (valA < valB) return dir === "asc" ? -1 : 1;
              if (valA > valB) return dir === "asc" ? 1 : -1;
              return 0;
            });
      
            tbody.innerHTML = "";
            rows.forEach((row) => tbody.appendChild(row));
          });
        });
      });
</script>

<!-- Complete Tray Scan Modal & New Popup Script with Simplified Single Top Tray Scan -->
<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", () => {
      const trayScanLinks = document.querySelectorAll(".tray-scan-btn");
      const trayModal = document.getElementById("trayScanModal");
      const closeTrayBtn = document.getElementById("closeTrayScanModal");
      if (closeTrayBtn && trayModal) {
        closeTrayBtn.addEventListener("click", function () {
          trayModal.classList.remove("open");
          trayModal.style.display = "none";
        });
      }
      if (event.target === trayModal) {
      trayModal.classList.remove("open");
      trayModal.style.display = "none"; // <-- Add this line
    }
      const detailsDiv = document.getElementById("trayScanDetails");
      const newPopupModal = document.getElementById("newPopupModal");
      const closeNewPopupBtn = document.getElementById("closeNewPopupModal");

      // ✅ NEW: Draft functionality variables
      let isDraftMode = false;
      let currentDraftData = null;

      trayScanLinks.forEach((link) => {
        link.addEventListener("click", (event) => {
          event.preventDefault();

          const row = event.target.closest("tr");
          const batchId = link.getAttribute('data-batch-id');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const isOnProceed = row.getAttribute('data-few-cases-acceptance') === 'True';
   
          trayModal.dataset.batchId = batchId;
          trayModal.dataset.stockLotId = stockLotId;

          const dateTime = row.cells[1].textContent.trim();
          const totalQuantity = row.cells[10].textContent.trim();
          const modelNo = row.getAttribute('data-model-no') || '';
          const modalHeader = document.getElementById("trayScanModalHeader");
          if (modalHeader) {
            modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
          }

          // If ip_onhold_picking is True, show read-only saved data
          // ✅ NEW: Check if this is a Top Tray Scan button (isOnProceed = true)
          if (isOnProceed) {
            // Skip the rejection modal and go directly to accepted tray modal
            fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
              .then(res => res.json())
              .then(rescanData => {
                if (rescanData.success) {
                  showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
                } else {
                  // Fallback to showing rejection modal if accepted tray data fails
                  showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
                }
              })
              .catch(error => {
                console.error('Error fetching accepted tray data:', error);
                // Fallback to showing rejection modal
                showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
              });
            return; // Exit early, don't show rejection modal
          }

          // ✅ EXISTING: Normal flow for new rejections (when isOnProceed = false)
          showRejectionModalFlow(batchId, stockLotId, isOnProceed, row);
        });
      });

      // ✅ NEW: Extract the original modal logic into a separate function
function showRejectionModalFlow(batchId, stockLotId, isOnProceed, row) {
  const trayModal = document.getElementById("trayScanModal");
  const detailsDiv = document.getElementById("trayScanDetails");
  
  trayModal.dataset.batchId = batchId;
  trayModal.dataset.stockLotId = stockLotId;

  const dateTime = row.cells[1].textContent.trim();
  const totalQuantity = row.cells[10].textContent.trim();
  const modelNo = row.getAttribute('data-model-no') || '';
  const modalHeader = document.getElementById("trayScanModalHeader");
  if (modalHeader) {
    modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
  }

  // If ip_onhold_picking is True, show read-only saved data
  if (isOnProceed) {
    showReadOnlyRejectionData(stockLotId, detailsDiv);
  } else {
    // ✅ UPDATED: Check for draft first, then show form
    checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
  }
  
  trayModal.style.display = "block";
  trayModal.classList.add("open");
}

      // ✅ NEW: Check for existing draft data
      function checkForExistingDraft(stockLotId, batchId, detailsDiv, row) {
        fetch(`/inputscreening/get_rejection_draft/?lot_id=${encodeURIComponent(stockLotId)}`)
          .then(res => res.json())
          .then(data => {
            if (data.success && data.has_draft) {
              isDraftMode = true;
              currentDraftData = data.draft_data;
              showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, currentDraftData);
            } else {
              isDraftMode = false;
              currentDraftData = null;
              showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
            }
          })
          .catch(error => {
            // Fallback to normal form
            isDraftMode = false;
            currentDraftData = null;
            showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
          });
      }

      // ✅ UPDATED: Function to show editable rejection form with optional draft data
      function showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, draftData) {
        // Get tray capacity from the row
        const trayCapacityText = row.cells[7]?.textContent || ''; // Tray Category-Capacity column
        const trayCapacity = trayCapacityText.includes('-') ? 
                            parseInt(trayCapacityText.split('-')[1]) : 10; // Default to 10
        
        // Set data attribute for tray capacity
        row.setAttribute('data-tray-capacity', trayCapacity);
        
        // ✅ NEW: Draft mode styling and indicators
        const draftIndicator = isDraftMode ? ' (Draft Mode)' : '';
        const draftAlert = isDraftMode ? `
          <div class="alert alert-info draft-mode-alert" style="margin: 10px 0; padding: 8px 12px; font-size: 14px; border-left: 4px solid #007bff; animation: draftModeGlow 2s ease-in-out infinite alternate;">
            <i class="fa fa-edit"></i> <strong>Draft Mode:</strong> You are editing saved draft data. Click "Draft" to save changes or "Proceed" to finalize.
          </div>
        ` : '';

        const headerColor = isDraftMode ? '#f39c12' : '#007bff';
        const inputStyle = isDraftMode ? 'background-color: #fff3cd; border-color: #f39c12; border-width: 2px;' : '';
        
        detailsDiv.innerHTML = `
          ${draftAlert}
          <div class="d-flex justify-content-between align-items-center mb-2" style="padding: 10px 0;">
            <h4 class="mb-0">Rejection Reason List${draftIndicator}</h4>
            
            <div class="form-check d-flex align-items-center">
                <input class="form-check-input" type="checkbox" id="batchRejection" 
                       ${draftData && draftData.is_batch_rejection ? 'checked' : ''} />
                <label class="form-check-label ms-2" for="batchRejection">Lot Rejection</label>
            </div>
          </div>
         
          <!-- ✅ UPDATED: Rejection form with dynamic tray ID generation -->
<div class="table-responsive" style="border: solid 1px black;">
  <table class="table table-bordered text-center" style="border: solid 2px black; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
    <thead style="border: solid 2px black; background-color: ${headerColor}; color: #fff;">
      <tr style="border: solid 1px black; color: #000;">
        <th style="padding: 12px;">S.No</th>
        <th style="padding: 12px;">Reason ID</th>
        <th style="padding: 12px;">Rejection Reason</th>
        <th style="padding: 12px;">Quantity</th>
        <th style="padding: 12px; min-width: 180px;">Tray ID(s)</th> <!-- ✅ UPDATED: Wider column for multiple inputs -->
      </tr>
    </thead>
    <tbody id="rejection-table-body">
      {% for reason in ip_rejection_reasons %}
      <tr data-batch-id="${batchId}" data-stock-lot-id="${stockLotId}">
        <td>{{ forloop.counter }}</td>
        <td style="color: {{ reason.row_color }};">{{ reason.rejection_reason_id }}</td>
        <td style="color: {{ reason.row_color }};">{{ reason.rejection_reason }}</td>
        <td>
          <input type="number" 
                 min="0" 
                 class="form-control rejection-qty-input" 
                 name="quantity_{{ forloop.counter }}" 
                 style="width: 80px; ${inputStyle}" 
                 data-reason-id="{{ reason.rejection_reason_id }}"
                 value="" />
        </td>
        <td style="vertical-align: top; padding: 8px 6px; min-width: 180px; max-width: 200px;">
          <!-- ✅ NEW: Dynamic tray ID container will be populated by JavaScript -->
          <span style="color: #999; font-style: italic;">Enter quantity first</span>
        </td>
      </tr>
      {% endfor %}
      <tr>
        <td colspan="4" style="text-align: right; font-weight: bold;">Total Qty</td>
        <td id="rejection-total-qty" style="font-weight: bold;">0</td>
      </tr>
    </tbody>
  </table>
</div>

          
          
           <br>
           <div id="batchRejectionMsg" style="margin-bottom:10px; color: #d32f2f; font-weight: bold;"></div>
         
            <div style="display: flex; justify-content: center; gap: 10px; margin-top: 20px;">
              ${isDraftMode ? `
                <button id="updateDraftButton" style="padding: 8px 16px; background: #f39c12; color: white; border: none; border-radius: 30px;">
                  <i class="fa fa-save"></i> Draft
                </button>
                <button id="proceedButton" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                  <i class="fa fa-check"></i> Proceed
                </button>
              ` : `
                <button id="draftButton" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">
                  <i class="fa fa-save"></i> Draft
                </button>       
                <button id="proceedButton" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">
                  <i class="fa fa-check"></i> Proceed
                </button>
              `}
              <button id="cancelButton" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 30px;">
                <i class="fa fa-times"></i> Cancel
              </button>
            </div>
        `;

        // ✅ NEW: Load draft data if available
        if (draftData) {
          loadDraftDataIntoForm(draftData);
        }

        // Add the updated event listeners for the editable form
        addEditableFormEventListeners(row, batchId, stockLotId);
      }


      
      // ✅ NEW: Load draft data into form
      // ✅ UPDATED: Load draft data into form (EXCLUDE SHORTAGE from tray scan)
function loadDraftDataIntoForm(draftData) {
  // Load rejection quantities
  if (draftData.rejection_data) {
    draftData.rejection_data.forEach(item => {
      const input = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
      if (input) {
        input.value = item.qty;
        input.style.backgroundColor = '#fff3cd';
        input.style.borderColor = '#f39c12';
        input.style.borderWidth = '2px';
      }
    });
    
    // Update total
    const totalQty = draftData.total_rejection_qty || 0;
    document.getElementById('rejection-total-qty').textContent = totalQty;
    
    // ✅ UPDATED: Calculate non-SHORTAGE quantity for tray scan
    let nonShortageQty = 0;
    draftData.rejection_data.forEach(item => {
      // Only count non-SHORTAGE quantities for tray scan
      if (item.reason && item.reason.toUpperCase() !== 'SHORTAGE') {
        nonShortageQuantity += parseInt(item.qty) || 0;
      }
    });

  }

  // Load batch rejection state
  if (draftData.is_batch_rejection) {
    const batchCheckbox = document.getElementById("batchRejection");
    if (batchCheckbox) {
      batchCheckbox.checked = true;
      // Disable quantity inputs
      document.querySelectorAll('.rejection-qty-input').forEach(input => {
        input.disabled = true;
      });
    }
  }
}


      // ✅ UPDATED: Function to add event listeners WITH draft functionality
      function addEditableFormEventListeners(row, batchId, stockLotId) {
        // Get tray capacity from the row data
        const trayCapacity = parseInt(row.getAttribute('data-tray-capacity')) || 10;
        console.log('Tray capacity:', trayCapacity);

        // Quantity validation with dynamic tray scan generation
        const availableQty = parseInt(row.getAttribute('data-available-qty'), 10) || 0;        
    
        // Enhanced quantity validation with proactive limiting
        // ✅ UPDATED: Enhanced quantity validation with dynamic tray ID generation
document.querySelectorAll('.rejection-qty-input').forEach(function(input, idx, allInputs) {
  // Real-time validation on input
  input.addEventListener('input', function() {
    const currentInput = this;
    const currentValue = parseInt(currentInput.value) || 0;
    const row = currentInput.closest('tr');
    const trayIdCell = row.querySelector('td:last-child'); // Tray ID column
    
    // Remove all previous qty errors
    document.querySelectorAll('.qty-error').forEach(function(span) { span.remove(); });

    // Calculate total from all OTHER inputs (excluding current)
    let totalFromOthers = 0;
    let hasQuantity = false;

    allInputs.forEach(function(otherInput) {
      if (otherInput !== currentInput) {
        const val = parseInt(otherInput.value) || 0;
        totalFromOthers += val;
        if (val > 0) hasQuantity = true;
      }
    });

    // Calculate maximum allowed value for current input
    const maxAllowed = Math.max(0, availableQty - totalFromOthers);
    
    // If current value exceeds maximum allowed, automatically adjust it
    if (currentValue > maxAllowed) {
      currentInput.value = maxAllowed;
      
      // Show helpful message
      let helpSpan = document.createElement('span');
      helpSpan.className = 'qty-help';
      helpSpan.style.color = '#f39c12';
      helpSpan.style.fontSize = '12px';
      helpSpan.style.display = 'block';
      helpSpan.style.marginTop = '2px';
      helpSpan.textContent = `Max allowed: ${maxAllowed} (Total limit: ${availableQty})`;
      currentInput.parentElement.appendChild(helpSpan);
      
      // Auto-hide the help message after 3 seconds
      setTimeout(() => {
        if (helpSpan.parentNode) {
          helpSpan.parentNode.removeChild(helpSpan);
        }
      }, 3000);
    }

    // Get final adjusted value
    const adjustedValue = parseInt(currentInput.value) || 0;
    const finalTotal = totalFromOthers + adjustedValue;
    
    // ✅ NEW: Generate dynamic tray ID inputs based on quantity
    generateDynamicTrayIdInputs(row, adjustedValue, trayIdCell);
    
    // Update total display
    document.getElementById('rejection-total-qty').textContent = finalTotal;
  });
});

// ✅ SIMPLIFIED: Calculate required trays based on standard capacity
function calculateRequiredTrays(rejectionQty, trayCapacity = 12) {
  if (rejectionQty <= 0) {
    return [];
  }
  
  const traysNeeded = Math.ceil(rejectionQty / trayCapacity);
  const traysWithQuantity = [];
  let remainingQty = rejectionQty;
  
  for (let i = 0; i < traysNeeded; i++) {
    const qtyForThisTray = Math.min(remainingQty, trayCapacity);
    traysWithQuantity.push({
      trayIndex: i,
      trayCapacity: trayCapacity,
      trayQty: qtyForThisTray,
      isTopTray: i === 0,
      isComplete: qtyForThisTray === trayCapacity,
      isPartial: qtyForThisTray < trayCapacity
    });
    remainingQty -= qtyForThisTray;
  }
  
  console.log(`✅ Simplified calculation for qty ${rejectionQty} with capacity ${trayCapacity}:`, 
    traysWithQuantity.map(t => `Tray ${t.trayIndex + 1}: ${t.trayQty}/${t.trayCapacity}`).join(', '));
  return traysWithQuantity;
}


// ✅ FIXED: Corrected column indices for proper tray distribution
function getActualTrayQuantitiesForCurrentLot() {
  const modal = document.getElementById("trayScanModal");
  const currentRow = document.querySelector('tr.highlighted-tray-scan');
  
  if (currentRow) {
    // Option 1: Get from data attribute if available
    const trayQtyList = currentRow.getAttribute('data-tray-qty-list');
    if (trayQtyList) {
      try {
        const parsed = JSON.parse(trayQtyList);
        if (parsed && parsed.length > 0) {
          console.log('Found actual tray quantities:', parsed);
          return parsed;
        }
      } catch (e) {
        console.log('Could not parse tray qty list:', e);
      }
    }
    
    // Option 2: Get from modal data if available
    if (modal && modal.traysData && modal.traysData.length > 0) {
      const actualQties = modal.traysData.map(tray => tray.tray_quantity || 0);
      console.log('Found actual tray quantities from modal:', actualQties);
      return actualQties;
    }
  }
  
  // Option 3: Fallback - Return standard capacity array for rejection calculation
  const trayCapacityText = currentRow?.cells[7]?.textContent || '';
  const standardCapacity = trayCapacityText.includes('-') ? 
                          parseInt(trayCapacityText.split('-')[1]) : 12;
  
  console.log(`Fallback: Using standard capacity ${standardCapacity} for rejection calculation`);
  
  // ✅ FIXED: For rejection scenarios, return an array of standard capacities
  // This allows the rejection calculation to work with standard tray sizes
  return Array(10).fill(standardCapacity); // Return 10 trays of standard capacity
}

// ✅ CORRECTED: Calculate complete tray rejections based on ACTUAL tray distribution
function calculateCompleteTraysFromActualDistribution(rejectionQty) {
  const actualTrayQties = getActualTrayQuantitiesForCurrentLot();
  const traysWithQuantity = [];
  let remainingQty = rejectionQty;
  
  console.log(`Calculating trays for rejection qty: ${rejectionQty}`);
  console.log(`Actual tray distribution: [${actualTrayQties.join(', ')}]`);
  
  // Go through trays in order (top tray first)
  for (let i = 0; i < actualTrayQties.length && remainingQty > 0; i++) {
    const trayCapacity = actualTrayQties[i];
    const qtyForThisTray = Math.min(remainingQty, trayCapacity);
    
    // ✅ NEW: Include ANY tray that gets some quantity (complete OR partial)
    traysWithQuantity.push({
      trayIndex: i,
      trayCapacity: trayCapacity,
      trayQty: qtyForThisTray,
      isTopTray: i === 0,
      isComplete: qtyForThisTray === trayCapacity,
      isPartial: qtyForThisTray < trayCapacity
    });
    
    remainingQty -= qtyForThisTray;
    
    console.log(`  Tray ${i + 1}: ${qtyForThisTray}/${trayCapacity} qty (${qtyForThisTray === trayCapacity ? 'Complete' : 'Partial'})`);
  }
  
  const result = {
    traysWithQuantity: traysWithQuantity,
    totalQtyDistributed: rejectionQty - remainingQty,
    // Only skip tray scanning for partial top tray (not complete)
    needsTrayScanning: traysWithQuantity.length > 0 && !(traysWithQuantity.length === 1 && traysWithQuantity[0].isPartial)
  };
  
  console.log(`Result:`, result);
  return result;
}

function generateDynamicTrayIdInputs(row, quantity, trayIdCell) {
  // Get current reason to check if it's SHORTAGE
  const reasonCell = row.cells[2];
  const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
  const reasonId = row.querySelector('.rejection-qty-input').getAttribute('data-reason-id');
  
  // Clear existing tray ID inputs
  trayIdCell.innerHTML = '';
  
  if (quantity <= 0) {
    trayIdCell.innerHTML = '<span style="color: #999; font-style: italic;">No tray required</span>';
    return;
  }
  
  if (reasonText === 'SHORTAGE') {
    trayIdCell.innerHTML = '<span style="color: #666; font-style: italic;">N/A (Shortage)</span>';
    return;
  }
  
  // ✅ FIXED: Use direct calculation instead of complex distribution logic
  const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                     document.querySelector('[data-stock-lot-id]') ||
                     document.querySelector('tbody tr');
  let trayCapacity = 12; // Default
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      trayCapacity = parseInt(trayCapacityText.split('-')[1]) || 12;
    }
  }
  
  // ✅ FIXED: Simple calculation - exactly what you expect!
  const traysNeeded = Math.ceil(quantity / trayCapacity);
  
  console.log(`🔧 Generating tray inputs for qty: ${quantity}, capacity: ${trayCapacity}, traysNeeded: ${traysNeeded}`);
  
  // Generate tray ID inputs for required trays
  const trayIdContainer = document.createElement('div');
  trayIdContainer.className = 'tray-id-container';
  trayIdContainer.style.cssText = `
    display: flex; flex-direction: column; gap: 6px; padding: 8px;
    background-color: #f8f9fa; border: 2px solid #007bff; border-radius: 8px;
  `;
  
  // Add header for tray container
  const headerDiv = document.createElement('div');
  headerDiv.style.cssText = `
    font-weight: bold; font-size: 12px; color: #007bff; margin-bottom: 4px;
    text-align: center; border-bottom: 1px solid #007bff; padding-bottom: 4px;
  `;
  headerDiv.textContent = `${traysNeeded} Tray${traysNeeded > 1 ? 's' : ''} Required`;
  trayIdContainer.appendChild(headerDiv);
  
  // Generate inputs for all required trays
  for (let i = 0; i < traysNeeded; i++) {
    let remainingQty = quantity - (i * trayCapacity);
    let trayQty = Math.min(trayCapacity, remainingQty);
    
    const trayInputGroup = document.createElement('div');
    trayInputGroup.style.cssText = `
      display: flex; align-items: center; gap: 8px; margin-bottom: 4px;
      padding: 6px; background-color: #ffffff; border: 1px solid #dee2e6;
      border-radius: 6px; transition: all 0.2s ease;
    `;
    
    // Tray number indicator
    const trayNumber = document.createElement('span');
    trayNumber.style.cssText = `
      font-size: 11px; font-weight: bold; color: #007bff;
      background-color: #e3f2fd; padding: 4px 8px; border-radius: 12px;
      min-width: 24px; text-align: center; border: 1px solid #2196f3;
    `;
    trayNumber.textContent = `${i + 1}`;
    
    // Tray ID input
    const trayInput = document.createElement('input');
    trayInput.type = 'text';
    trayInput.className = 'form-control rejection-tray-id-input';
    trayInput.style.cssText = `
      flex: 1; font-size: 12px; padding: 6px 10px;
      border: 2px solid #ced4da; border-radius: 6px;
      transition: all 0.2s ease; text-align: center; font-weight: 500;
    `;
    trayInput.placeholder = `Scan Tray ID ${i + 1}`;
    
    // Set data attributes
    trayInput.setAttribute('data-tray-index', i);
    trayInput.setAttribute('data-tray-capacity', trayCapacity);
    trayInput.setAttribute('data-tray-qty', trayQty);
    trayInput.setAttribute('data-is-complete', trayQty === trayCapacity);
    trayInput.setAttribute('data-is-partial', trayQty < trayCapacity);
    trayInput.setAttribute('data-reason-id', reasonId);
    trayInput.setAttribute('data-rejection-qty', quantity);
    trayInput.setAttribute('data-rejection-reason', reasonText);
    trayInput.setAttribute('data-expected-total-trays', traysNeeded);
    trayInput.setAttribute('data-tray-position-in-rejection', i + 1);
    
    // Error span for this specific tray
    const errorSpan = document.createElement('span');
    errorSpan.className = 'rejection-tray-error';
    errorSpan.style.cssText = `
      color: #dc3545; font-size: 10px; display: none;
      position: absolute; top: 100%; left: 0; right: 0;
      background: #f8d7da; border: 1px solid #f5c6cb;
      border-radius: 4px; padding: 4px 8px; margin-top: 2px; z-index: 10;
    `;
    
    // Position relative for error positioning
    trayInputGroup.style.position = 'relative';
    
    trayInputGroup.appendChild(trayNumber);
    trayInputGroup.appendChild(trayInput);
    trayInputGroup.appendChild(errorSpan);
    
    trayIdContainer.appendChild(trayInputGroup);
  }
  
  // Add summary footer
  const footerDiv = document.createElement('div');
  footerDiv.style.cssText = `
    font-size: 10px; color: #6c757d; text-align: center;
    margin-top: 6px; padding-top: 6px; border-top: 1px solid #dee2e6; font-style: italic;
  `;
  footerDiv.textContent = `Total quantity: ${quantity} across ${traysNeeded} tray${traysNeeded > 1 ? 's' : ''}`;
  trayIdContainer.appendChild(footerDiv);
  
  trayIdCell.appendChild(trayIdContainer);
  
  // Add validation for all new tray inputs
  addMultipleTrayIdValidationWithDynamic(trayIdCell);
}


// ✅ Helper function to get total rejection quantity for a specific reason
function getTotalRejectionQuantityForReason(reasonId) {
  const qtyInput = document.querySelector(`input[data-reason-id="${reasonId}"].rejection-qty-input`);
  return qtyInput ? parseInt(qtyInput.value) || 0 : 0;
}


// ✅ UPDATED: Enhanced validation with session tracking
function addMultipleTrayIdValidationWithDynamic(trayIdCell) {
  const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
  
  trayInputs.forEach(function(input, idx) {
    // Remove existing event listeners
    input.removeEventListener('blur', input._blurHandler);
    input.removeEventListener('input', input._inputHandler);
    input.removeEventListener('keydown', input._keydownHandler);
    
    // Track validation state
    input._hasError = false;
    input._isValidating = false;
    
    // Input event for counter update
    input._inputHandler = function() {
      this._hasError = false;
      const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
      if (errorSpan) {
        errorSpan.style.display = 'none';
        errorSpan.textContent = '';
      }
      updateRejectionScanCounter();
    };
    input.addEventListener('input', input._inputHandler);
    
    // Keydown handler
    input._keydownHandler = function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        if (this._hasError || this._isValidating || !this.value.trim()) {
          return;
        }
        
        // Move to next tray input in same cell or next row
        const nextInput = trayInputs[idx + 1];
        if (nextInput) {
          nextInput.focus();
        }
      }
    };
    input.addEventListener('keydown', input._keydownHandler);
    
    // ✅ ENHANCED: Session-aware blur validation
    input._blurHandler = function() {
      const trayId = this.value.trim();
      const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
      this._hasError = false;
    
      // Always clear error before validation
      if (errorSpan) {
        errorSpan.textContent = '';
        errorSpan.style.display = 'none';
      }
    
      if (!trayId) {
        updateRejectionScanCounter();
        return;
      }
    
      this._isValidating = true;
    
      // Check for duplicates within current form
      let isDuplicate = false;
      document.querySelectorAll('.rejection-tray-id-input').forEach(function(otherInput) {
        if (otherInput !== input && otherInput.value.trim() === trayId) {
          isDuplicate = true;
        }
      });
    
      if (isDuplicate) {
        this._hasError = true;
        this._isValidating = false;
        if (errorSpan) {
          errorSpan.innerHTML = `❌ Duplicate`;
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#dc3545';
        }
        setTimeout(() => {
          this.value = '';
          this._hasError = false;
          if (errorSpan) errorSpan.style.display = 'none';
          this.focus();
          updateRejectionScanCounter();
        }, 800);
        return;
      }

      // ✅ NEW: Collect current session allocations before validation
      const currentSessionAllocations = collectCurrentSessionAllocations(this);
      const currentLotId = getCurrentLotId();
      const rejectionQty = parseInt(this.getAttribute('data-rejection-qty')) || 0;
      
      const rejectionContext = {
        tray_id: trayId,
        lot_id: currentLotId,
        rejection_qty: rejectionQty,
        current_session_allocations: JSON.stringify(currentSessionAllocations)  // ✅ NEW: Pass session data
      };
      
      console.log('🔍 Session-aware validation context:', rejectionContext);
      
      // ✅ UPDATED: Use session-aware validation endpoint
      const queryParams = new URLSearchParams(rejectionContext).toString();
      fetch(`/inputscreening/reject_check_tray_id_session_aware/?${queryParams}`)
        .then(res => res.json())
        .then(data => {
          this._isValidating = false;
          
          console.log('🔍 Session-aware validation response:', data);
    
          if (errorSpan) {
            if (data.exists && data.valid_for_rejection) {
              this._hasError = false;
              
              // ✅ ENHANCED: Show session-aware validation results
              let successMessage = `✅ ${data.status_message}`;
              
              // Add session information
              if (data.session_remaining_distribution) {
                console.log(`📊 Session remaining: [${data.session_remaining_distribution.join(', ')}]`);
              }
              
              errorSpan.innerHTML = successMessage;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#155724';
              errorSpan.style.backgroundColor = '#d4edda';
              errorSpan.style.padding = '4px 8px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '11px';
              
              setTimeout(() => {
                errorSpan.style.display = 'none';
                updateRejectionScanCounter();
              }, 3000);
              
            } else {
              this._hasError = true;
              
              // ✅ ENHANCED: Show session-aware error messages
              let errorMessage = `❌ ${data.status_message || 'Invalid'}`;
              
              // Show session information for debugging
              if (data.session_remaining_distribution) {
                const validQties = data.session_remaining_distribution.join(', ');
                console.log(`📊 Available in session: [${validQties}]`);
                if (data.already_allocated_in_session) {
                  errorMessage += ` (Already used in session)`;
                }
              }
              
              errorSpan.innerHTML = errorMessage;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#721c24';
              errorSpan.style.backgroundColor = '#f8d7da';
              errorSpan.style.padding = '4px 8px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.fontSize = '11px';
              
              setTimeout(() => {
                this.value = '';
                this._hasError = false;
                errorSpan.style.display = 'none';
                this.focus();
                updateRejectionScanCounter();
              }, 4000);
            }
          } else {
            updateRejectionScanCounter();
          }
        })
        .catch(() => {
          this._isValidating = false;
          this._hasError = true;
          if (errorSpan) {
            errorSpan.innerHTML = '❌ Connection Error';
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            setTimeout(() => {
              this.value = '';
              this._hasError = false;
              errorSpan.style.display = 'none';
              this.focus();
              updateRejectionScanCounter();
            }, 1000);
          } else {
            updateRejectionScanCounter();
          }
        });
    };
    input.addEventListener('blur', input._blurHandler);
  });
}



function collectCurrentSessionAllocations(excludeInput) {
  const allocations = [];
  
  console.log('📊 [Session Collection] Starting allocation collection...');
  
  // Get all rejection quantity inputs and their associated tray scans
  document.querySelectorAll('.rejection-qty-input').forEach(qtyInput => {
    const qty = parseInt(qtyInput.value) || 0;
    const reasonId = qtyInput.getAttribute('data-reason-id');
    
    if (qty > 0) {
      const row = qtyInput.closest('tr');
      const reasonCell = row.cells[2];
      const reasonText = reasonCell ? reasonCell.textContent.trim() : '';
      const trayIdCell = row.querySelector('td:last-child');
      const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
      
      console.log(`📋 [Session Collection] Processing reason ${reasonId} (${reasonText}): qty=${qty}, inputs=${trayInputs.length}`);
      
      // ✅ ENHANCED: Count valid tray scans more accurately
      const validTrayIds = [];
      let validTrayCount = 0;
      
      trayInputs.forEach((trayInput, index) => {
        const trayId = trayInput.value.trim();
        
        // Skip the input we're currently validating
        if (trayInput === excludeInput) {
          console.log(`   ⏭️ Skipping current input ${index + 1}: "${trayId}" (being validated)`);
          return;
        }
        
        if (trayId) {
          // Check if this tray input has a validation error
          const errorSpan = trayInput.parentElement.querySelector('.rejection-tray-error');
          const hasError = errorSpan && 
                           errorSpan.style.display === 'block' && 
                           (errorSpan.textContent.includes('❌') || errorSpan.style.color === '#721c24');
          
          if (!hasError) {
            validTrayIds.push(trayId);
            validTrayCount++;
            console.log(`   ✅ Valid tray ${index + 1}: "${trayId}"`);
          } else {
            console.log(`   ❌ Invalid tray ${index + 1}: "${trayId}" (has error)`);
          }
        } else {
          console.log(`   ⭕ Empty tray ${index + 1}`);
        }
      });
      
      // ✅ CRITICAL: Only add allocation if there are valid tray scans
      if (validTrayCount > 0) {
        const allocation = {
          reason_id: reasonId,
          reason_text: reasonText,
          qty: qty,
          tray_count: validTrayCount,
          tray_ids: validTrayIds,
          expected_trays: Math.ceil(qty / 12) // For debugging
        };
        
        allocations.push(allocation);
        console.log(`   ✅ Added allocation:`, allocation);
      } else {
        console.log(`   ⚠️ No valid trays for reason ${reasonId}, skipping allocation`);
      }
    }
  });
  
  console.log('📊 [Session Collection] FINAL allocations:', allocations);
  console.log(`📊 [Session Collection] Summary: ${allocations.length} active allocations`);
  
  // Log summary for debugging
  allocations.forEach(alloc => {
    console.log(`   📋 ${alloc.reason_id}: Qty ${alloc.qty} using ${alloc.tray_count} tray(s)`);
  });
  
  return allocations;
}


// ✅ NEW: Function to calculate tray distribution with remainder FIRST
function calculateTrayDistribution(totalQuantity, trayCapacities) {
  const distribution = [];
  
  if (totalQuantity <= 0 || !trayCapacities.length) {
    return distribution;
  }
  
  // Use the first tray capacity as the standard capacity
  const standardCapacity = trayCapacities[0];
  
  // Calculate how many full trays we need and what the remainder is
  const fullTrays = Math.floor(totalQuantity / standardCapacity);
  const remainder = totalQuantity % standardCapacity;
  
  console.log(`Distribution calculation: total=${totalQuantity}, capacity=${standardCapacity}, fullTrays=${fullTrays}, remainder=${remainder}`);
  
  let trayIndex = 0;
  
  // ✅ FIXED: Put remainder FIRST (if there is one)
  if (remainder > 0) {
    distribution.push({
      capacity: trayCapacities[trayIndex] || standardCapacity,
      qty: remainder,
      index: trayIndex
    });
    trayIndex++;
  }
  
  // Then add full capacity trays
  for (let i = 0; i < fullTrays; i++) {
    const currentCapacity = trayCapacities[trayIndex] || standardCapacity;
    distribution.push({
      capacity: currentCapacity,
      qty: Math.min(standardCapacity, currentCapacity), // Use min to respect individual tray limits
      index: trayIndex
    });
    trayIndex++;
  }
  
  console.log(`Final distribution:`, distribution);
  return distribution;
}

// ✅ NEW: Function to get tray capacities for current lot
function getTrayCapacitiesForCurrentLot() {
  // You can implement this based on your data source
  // For now, returning a sample array
  // You might want to get this from:
  // 1. TotalStockModel tray_capacity
  // 2. TrayId records for current lot
  // 3. ModelMasterCreation tray_capacity
  
  const modal = document.getElementById("trayScanModal");
  const currentRow = document.querySelector('tr.highlighted-tray-scan');
  
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || ''; // Tray Category-Capacity column
    const trayCapacity = trayCapacityText.includes('-') ? 
                        parseInt(trayCapacityText.split('-')[1]) : 10;
    
    // For simplicity, assuming all trays have same capacity
    // You can modify this to get actual tray capacities from your API
    return Array(10).fill(trayCapacity); // Assuming max 10 trays with same capacity
  }
  
  // Default fallback
  return [6, 12, 12, 10, 10, 10, 10, 10, 10, 10]; // Sample capacities
}

// ✅ NEW: Enhanced validation for multiple tray ID inputs
function addMultipleTrayIdValidation(trayIdCell) {
  const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
  
  trayInputs.forEach(function(input, idx) {
    // Remove existing event listeners
    input.removeEventListener('blur', input._blurHandler);
    input.removeEventListener('input', input._inputHandler);
    input.removeEventListener('keydown', input._keydownHandler);
    
    // Track validation state
    input._hasError = false;
    input._isValidating = false;
    
    // Input event for counter update
    input._inputHandler = function() {
      this._hasError = false;
      const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
      if (errorSpan) {
        errorSpan.style.display = 'none';
        errorSpan.textContent = '';
      }
      updateRejectionScanCounter();
    };
    input.addEventListener('input', input._inputHandler);
    
    // Keydown handler
    input._keydownHandler = function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        if (this._hasError || this._isValidating || !this.value.trim()) {
          return;
        }
        
        // Move to next tray input in same cell or next row
        const nextInput = trayInputs[idx + 1];
        if (nextInput) {
          nextInput.focus();
        }
      }
    };
    input.addEventListener('keydown', input._keydownHandler);
    
    // Blur validation
        input._blurHandler = function() {
          const trayId = this.value.trim();
          const errorSpan = this.parentElement.querySelector('.rejection-tray-error');
          this._hasError = false;
        
          // Always clear error before validation
          if (errorSpan) {
            errorSpan.textContent = '';
            errorSpan.style.display = 'none';
          }
        
          if (!trayId) {
            updateRejectionScanCounter();
            return;
          }
        
          this._isValidating = true;
        
          // Check for duplicates
          let isDuplicate = false;
          document.querySelectorAll('.rejection-tray-id-input').forEach(function(otherInput) {
            if (otherInput !== input && otherInput.value.trim() === trayId) {
              isDuplicate = true;
            }
          });
        
          if (isDuplicate) {
            this._hasError = true;
            this._isValidating = false;
            if (errorSpan) {
              errorSpan.innerHTML = `❌ Duplicate`;
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#dc3545';
            }
            setTimeout(() => {
              this.value = '';
              this._hasError = false;
              if (errorSpan) errorSpan.style.display = 'none';
              this.focus();
              updateRejectionScanCounter(); // ✅ Always update after error
            }, 800);
            return;
          }
        
          // Server validation
          const currentLotId = getCurrentLotId();
          fetch(`/inputscreening/reject_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(currentLotId)}`)
            .then(res => res.json())
            .then(data => {
              this._isValidating = false;
        
              if (errorSpan) {
                if (data.exists) {
                  this._hasError = false;
                  errorSpan.innerHTML = `✅ ${data.status_message}`;
                  errorSpan.style.display = 'block';
                  errorSpan.style.color = '#155724';
                  setTimeout(() => {
                    errorSpan.style.display = 'none';
                    updateRejectionScanCounter(); // ✅ Update after success
                  }, 1000);
                } else {
                  this._hasError = true;
                  errorSpan.innerHTML = `❌ ${data.status_message || 'Invalid'}`;
                  errorSpan.style.display = 'block';
                  errorSpan.style.color = '#721c24';
                  setTimeout(() => {
                    this.value = '';
                    this._hasError = false;
                    errorSpan.style.display = 'none';
                    this.focus();
                    updateRejectionScanCounter(); // ✅ Update after error
                  }, 1000);
                }
              } else {
                updateRejectionScanCounter();
              }
            })
            .catch(() => {
              this._isValidating = false;
              this._hasError = true;
              if (errorSpan) {
                errorSpan.innerHTML = '❌ Error';
                errorSpan.style.display = 'block';
                errorSpan.style.color = '#721c24';
                setTimeout(() => {
                  this.value = '';
                  this._hasError = false;
                  errorSpan.style.display = 'none';
                  this.focus();
                  updateRejectionScanCounter(); // ✅ Update after network error
                }, 1000);
              } else {
                updateRejectionScanCounter();
              }
            });
        };
    input.addEventListener('blur', input._blurHandler);
  });
}



                // Place this after your existing .rejection-qty-input logic
        document.querySelectorAll('.rejection-qty-input').forEach(function(qtyInput) {
          qtyInput.addEventListener('input', function() {
            const row = qtyInput.closest('tr');
            const trayInput = row.querySelector('.rejection-tray-id-input');
            if (parseInt(qtyInput.value) > 0) {
              trayInput.disabled = false;
              trayInput.required = true;
            } else {
              trayInput.value = '';
              trayInput.disabled = true;
              trayInput.required = false;
            }
          });
          // Optionally, trigger once on page load to set initial state
          qtyInput.dispatchEvent(new Event('input'));
        });
// Batch rejection checkbox event listener
        const batchRejectionCheckbox = document.getElementById("batchRejection");
        const rejectionTableBody = document.getElementById("rejection-table-body");
        
        if (batchRejectionCheckbox && rejectionTableBody) {
          batchRejectionCheckbox.addEventListener("change", function () {
            const inputs = rejectionTableBody.querySelectorAll("input");
            if (this.checked) {
              inputs.forEach(input => {
                input.disabled = true;
                input.value = ""; // Clear values
              });
              document.getElementById('rejection-total-qty').textContent = "0";
              hideRejectionTrayScanTable();
            } else {
              inputs.forEach(input => {
                input.disabled = false;
              });
            }
          });
        }

        // ✅ UPDATED: Button event listeners based on mode
        if (isDraftMode) {
          // Update Draft button (renamed to "Draft")
          const updateDraftBtn = document.getElementById("updateDraftButton");
          if (updateDraftBtn) {
            updateDraftBtn.addEventListener("click", () => handleUpdateDraft(stockLotId, batchId));
          }
        } else {
          // Regular Draft button
          const draftBtn = document.getElementById("draftButton");
          if (draftBtn) {
            draftBtn.addEventListener("click", () => handleSaveDraft(stockLotId, batchId));
          }
        }

        // Proceed button (works for both modes)
        const proceedBtn = document.getElementById("proceedButton");
        if (proceedBtn) {
          proceedBtn.addEventListener("click", () => handleProceed(stockLotId, batchId, isDraftMode));
        }

        // Cancel button
        const cancelBtn = document.getElementById("cancelButton");
       if (cancelBtn) {
  cancelBtn.addEventListener("click", () => {
    document.getElementById("trayScanModal").classList.remove("open");
    
    // ✅ NEW: Also close trayScanModal if it's open
    const trayScanModal = document.getElementById("trayScanModal");
    if (trayScanModal && trayScanModal.classList.contains("open")) {
      trayScanModal.classList.remove("open");
      trayScanModal.style.display = "none";
    }
    
    // Add a slight delay then refresh table data only
    setTimeout(() => {
      refreshTableData();
    }, 300);
  });
}
      }

      // ✅ NEW: Handle save draft
      function handleSaveDraft(stockLotId, batchId) {
        const draftData = collectFormData(stockLotId, batchId);
        
        if (!validateDraftData(draftData)) {
          return;
        }
        
        // Add ip_onhold_picking flag for draft
        draftData.ip_onhold_picking = true;
        
        fetch('/inputscreening/save_rejection_draft/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(draftData)
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            showSuccessMessage('Draft saved successfully!', '#007bff');
            // Close modal and refresh 
            setTimeout(() => {
              document.getElementById("trayScanModal").classList.remove("open");
              refreshTableData();

            }, 1500);
          } else {
            showErrorMessage(data.error || 'Failed to save draft');
          }
        })
        .catch(error => {
          showErrorMessage('Network error occurred');
        });
      }

      // ✅ NEW: Handle update draft
      function handleUpdateDraft(stockLotId, batchId) {
        const draftData = collectFormData(stockLotId, batchId);
        
        if (!validateDraftData(draftData)) {
          return;
        }
        
        // Add ip_onhold_picking flag for draft
        draftData.ip_onhold_picking = true;
        
        fetch('/inputscreening/save_rejection_draft/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify(draftData)
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            showSuccessMessage('Draft updated successfully!', '#f39c12');
            setTimeout(() => {
              document.getElementById("trayScanModal").classList.remove("open");
              window.location.reload(); // <-- Only refresh table, not the whole page
            }, 1500);
            currentDraftData = draftData;
          } else {
            showErrorMessage(data.error || 'Failed to update draft');
          }
        })
        .catch(error => {
          showErrorMessage('Network error occurred');
        });
      }

      // ✅ UPDATED: Handle proceed (works for both regular and draft mode)
      function handleProceed(stockLotId, batchId, isDraftMode) {
        const formData = collectFormData(stockLotId, batchId);
        // Disable Proceed, Draft, and Cancel buttons
        const draftBtn = document.getElementById("draftButton");
        const updateDraftBtn = document.getElementById("updateDraftButton");
        const proceedBtn = document.getElementById("proceedButton");
        const cancelBtn = document.getElementById("cancelButton");

        [draftBtn, updateDraftBtn, proceedBtn, cancelBtn].forEach(btn => {
            if (btn) {
                btn.disabled = true;
                btn.style.opacity = "0.6";
                btn.style.cursor = "not-allowed";
                btn.style.background = "#bdbdbd";
                btn.style.color = "#fff";
                btn.classList.add("disabled");
            }
        });
            
        // Validate form data for final submission
        if (!validateFormDataForProceed(formData)) {
          return;
        }

        // If in draft mode, delete draft first, then proceed with normal flow
        if (isDraftMode) {
          fetch('/inputscreening/delete_rejection_draft/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCookie('csrftoken')
            },
            body: JSON.stringify({ lot_id: stockLotId })
          })
          .then(() => {
            // Proceed with normal rejection flow
            proceedWithRejection(formData, stockLotId, batchId);
          })
          .catch(error => {
            // Still proceed with rejection even if draft deletion fails
            proceedWithRejection(formData, stockLotId, batchId);
          });
        } else {
          // Normal flow
          proceedWithRejection(formData, stockLotId, batchId);
        }
      }

function collectFormData(stockLotId, batchId) {
  const rejection_data = [];
  const tray_scans = [];
  const is_batch_rejection = document.getElementById("batchRejection").checked;

  console.log("🔄 [collectFormData] Starting data collection...");

  // Collect rejection data with tray IDs only for complete tray rejections
  document.querySelectorAll('.rejection-qty-input').forEach(input => {
    const qty = parseInt(input.value) || 0;
    const row = input.closest('tr');
    const reasonId = input.dataset.reasonId;
    
    console.log(`📊 Processing row: reasonId=${reasonId}, qty=${qty}`);
    
    if (qty > 0) {
      // ✅ ALWAYS add to rejection_data (this includes partial quantities)
      rejection_data.push({
        reason_id: reasonId,
        qty: qty
      });
      
      console.log(`✅ Added to rejection_data: ${reasonId} - ${qty}`);
      
      // ✅ NEW: Only collect tray IDs if there are actual tray input fields
      const trayIdCell = row.querySelector('td:last-child');
      const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
      
      console.log(`🔍 Found ${trayInputs.length} tray inputs for reason ${reasonId}`);
      
      if (trayInputs.length === 0) {
        console.log(`   ℹ️ No tray inputs found - this is a partial quantity rejection`);
      } else {
        let rowTrayScans = 0;
        trayInputs.forEach((trayInput, index) => {
          const trayId = trayInput.value.trim();
          const trayQty = parseInt(trayInput.getAttribute('data-tray-qty')) || 0;
          
          console.log(`   Tray ${index + 1}: id="${trayId}", qty=${trayQty}`);
          
          if (trayId && trayQty > 0) {
            tray_scans.push({
              tray_id: trayId,
              tray_qty: trayQty,
              reason_id: reasonId
            });
            rowTrayScans++;
            console.log(`   ✅ Added tray scan: ${trayId} (${trayQty}) for reason ${reasonId}`);
          } else if (trayId && trayQty === 0) {
            console.log(`   ⚠️ Tray ID "${trayId}" has zero quantity, skipping`);
          } else if (!trayId && trayQty > 0) {
            console.log(`   ⚠️ Missing tray ID for quantity ${trayQty}, skipping`);
          }
        });
        
        console.log(`📋 Row summary: ${rowTrayScans} tray scans collected for reason ${reasonId}`);
      }
    }
  });

  const result = {
    lot_id: stockLotId,
    batch_id: batchId,
    rejection_data: rejection_data,
    tray_scans: tray_scans,
    is_batch_rejection: is_batch_rejection,
    total_rejection_qty: rejection_data.reduce((sum, item) => sum + item.qty, 0)
  };

  console.log("📤 [collectFormData] Final result:");
  console.log("   - rejection_data:", result.rejection_data);
  console.log("   - tray_scans:", result.tray_scans);
  console.log("   - total_rejection_qty:", result.total_rejection_qty);
  console.log("   - Note: rejection_data qty may be > tray_scans qty (due to partial quantities)");

  return result;
}

      // ✅ NEW: Validate draft data (less strict)
      function validateDraftData(formData) {
        if (formData.is_batch_rejection) {
          return true; // Batch rejection is always valid for draft
        }

        // For draft, we just need at least some data
        if (formData.rejection_data.length === 0 && formData.tray_scans.length === 0) {
          showErrorMessage('Please enter at least some rejection data before saving as draft.');
          return false;
        }

        return true;
      }

// ✅ SIMPLIFIED: Update validation logic to use new calculation
function validateFormDataForProceed(formData) {
  console.log("🔍 [validateFormDataForProceed] Starting validation...");
  
  if (formData.is_batch_rejection) {
    console.log("✅ Batch rejection - validation passed");
    return true;
  }

  if (formData.rejection_data.length === 0) {
    showErrorMessage('Please enter at least one rejection quantity.');
    return false;
  }

  // Check if ALL rejections are SHORTAGE
  const isAllShortage = formData.rejection_data.every(item => {
    const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
    if (reasonElement) {
      const reasonCell = reasonElement.closest('tr').cells[2];
      const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
      return reasonText === 'SHORTAGE';
    }
    return false;
  });

  if (isAllShortage) {
    console.log("✅ All SHORTAGE rejections - no tray scans required");
    return true;
  }

  // ✅ SIMPLIFIED: Validate tray scanning requirements
  let validationErrors = [];
  
  // Get tray capacity
  const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                     document.querySelector('[data-stock-lot-id]') ||
                     document.querySelector('tbody tr');
  let trayCapacity = 12; // Default
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      trayCapacity = parseInt(trayCapacityText.split('-')[1]) || 12;
    }
  }
  
  console.log(`🔧 Using tray capacity: ${trayCapacity} for validation`);
  
  formData.rejection_data.forEach(item => {
    const reasonElement = document.querySelector(`input[data-reason-id="${item.reason_id}"]`);
    if (!reasonElement) return;
    
    const reasonCell = reasonElement.closest('tr').cells[2];
    const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
    
    if (reasonText !== 'SHORTAGE') {
      const row = reasonElement.closest('tr');
      const trayIdCell = row.querySelector('td:last-child');
      const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
      
      // ✅ SIMPLIFIED: Calculate expected number of trays
      const expectedTrays = Math.ceil(item.qty / trayCapacity);
      
      console.log(`🔍 Validating ${reasonText}: qty=${item.qty}, expectedTrays=${expectedTrays}, foundInputs=${trayInputs.length}`);
      
      // Check if we have the right number of inputs
      if (trayInputs.length !== expectedTrays) {
        validationErrors.push(`${reasonText}: Expected ${expectedTrays} tray input(s), found ${trayInputs.length}`);
      }
      
      // Check if all inputs are filled
      let missingTrayIds = 0;
      trayInputs.forEach((trayInput, index) => {
        const trayId = trayInput.value.trim();
        if (!trayId) {
          missingTrayIds++;
        }
      });
      
      if (missingTrayIds > 0) {
        validationErrors.push(`${reasonText}: Missing ${missingTrayIds} tray ID(s)`);
      }
    }
  });

  if (validationErrors.length > 0) {
    showErrorMessage(`Validation errors:\n• ${validationErrors.join('\n• ')}`);
    console.log("❌ Validation errors:", validationErrors);
    return false;
  }

  console.log("✅ Validation passed");
  return true;
}


// ✅ UPDATED: Enhanced error message display
function showErrorMessage(message) {
  const msgDiv = document.getElementById("batchRejectionMsg");
  if (msgDiv) {
    msgDiv.style.color = "#d32f2f";
    msgDiv.style.backgroundColor = "#ffebee";
    msgDiv.style.border = "1px solid #f44336";
    msgDiv.style.padding = "8px 12px";
    msgDiv.style.borderRadius = "4px";
    msgDiv.style.marginTop = "10px";
    msgDiv.textContent = message;
    
    // Auto-hide after 8 seconds
    setTimeout(() => {
      msgDiv.textContent = "";
      msgDiv.style.backgroundColor = "";
      msgDiv.style.border = "";
      msgDiv.style.padding = "";
       }, 8000);
  }
  
  // Also log to console
  console.log("❌ Error:", message);
}
  


      // ✅ NEW: Proceed with actual rejection (existing logic)
      function proceedWithRejection(formData, stockLotId, batchId) {
        if (formData.is_batch_rejection) {
          // Handle batch rejection
          handleBatchRejection(batchId, stockLotId);
        } else {
          // Handle tray-wise rejection  
          handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData);
        }
      }

      // ✅ UPDATED: Handle tray-wise rejection with form data
function handleTrayWiseRejectionWithFormData(batchId, stockLotId, formData) {
  const msgDiv = document.getElementById("batchRejectionMsg");
  const proceedButton = document.getElementById("proceedButton");
  
  if (proceedButton) proceedButton.disabled = true;
  
  // ✅ FIXED: Use formData.tray_scans directly instead of recreating tray_rejections
  console.log('Using tray_scans from formData:', formData.tray_scans);
  console.log('Using rejection_data from formData:', formData.rejection_data);
  
  // Send to server with correct parameter names
  fetch('/inputscreening/tray_rejection/', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': getCookie('csrftoken')
    },
    body: JSON.stringify({
      lot_id: stockLotId,
      batch_id: batchId,
      tray_scans: formData.tray_scans,      // ✅ Use collected tray_scans
      rejection_data: formData.rejection_data // ✅ Use collected rejection_data
    })
  })
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      // Disable all inputs
      document.querySelectorAll('.rejection-qty-input, .rejection-tray-id-input').forEach(input => {
        input.disabled = true;
      });
      
      window.trayRejectionSaved = true;
      
      if (msgDiv) {
        msgDiv.style.color = "#388e3c";
        msgDiv.textContent = "Rejected Tray saved!";
      }

      // Update main table row
      const mainTableRow = document.querySelector(`tr[data-stock-lot-id="${stockLotId}"]`);
      if (mainTableRow) {
        // Update Lot Status cell
        const lotStatusCell = mainTableRow.querySelector('td:nth-child(17)');
        if (lotStatusCell) {
          lotStatusCell.innerHTML = `
            <div class="d-inline-block px-3 fw-semibold text-center rounded-pill"
              style="border: 2px solid #4997ac; background-color: #d1f2f3; color: #03425d;
              font-size: 13px; white-space: nowrap;
              padding-top: 0.5rem; padding-bottom: 0.5rem;">
              Draft
            </div>
          `;
        }

        // Disable Accept button
        const acceptBtn = mainTableRow.querySelector('.btn-twitter');
        if (acceptBtn) {
          acceptBtn.disabled = true;
          acceptBtn.style.pointerEvents = 'none';
          acceptBtn.style.opacity = '0.6';
          acceptBtn.style.cursor = 'not-allowed';
          acceptBtn.innerHTML = `<i class="fa fa-check-circle"></i>Accept`;
          acceptBtn.classList.add('disabled');
        }
      
        // Enable Top Tray Scan button
        const partialRejectBtn = mainTableRow.querySelector('.btn-youtube.tray-scan-btn');
        if (partialRejectBtn) {
          partialRejectBtn.disabled = false;
          partialRejectBtn.style.pointerEvents = 'auto';
          partialRejectBtn.style.opacity = '1';
          partialRejectBtn.style.cursor = 'pointer';
          partialRejectBtn.innerHTML = `<i class="fa fa-times-circle"></i>Set Top Tray`;
          partialRejectBtn.style.backgroundColor = '#e57373';
          partialRejectBtn.classList.remove('disabled');
        }
      
        // Set Process Status "S" icon to half-filled
        const processIcons = mainTableRow.querySelectorAll('.d-flex > div');
        if (processIcons.length > 1) {
          processIcons[1].style.background = 'linear-gradient(to right, #0c8249 50%, #bdbdbd 50%)';
        }

        // Update quantities if provided in response
        if (data.lot_qty !== undefined) {
          const lotQtySpan = mainTableRow.querySelector('td:nth-child(11) .lot-qty');
          if (lotQtySpan) {
            lotQtySpan.textContent = data.lot_qty;
            lotQtySpan.style.backgroundColor = '#fff3cd';
            lotQtySpan.style.borderRadius = '4px';
            setTimeout(() => { lotQtySpan.style.backgroundColor = ''; }, 1200);
          }
        }
        
        if (data.physical_qty !== undefined) {
          const physicalQtyInput = mainTableRow.querySelector('td:nth-child(12) .physical-qty-input');
          if (physicalQtyInput) {
            physicalQtyInput.value = data.physical_qty;
            physicalQtyInput.style.backgroundColor = '#fff3cd';
            physicalQtyInput.style.borderColor = '#ffc107';
            setTimeout(() => { 
              physicalQtyInput.style.backgroundColor = ''; 
              physicalQtyInput.style.borderColor = ''; 
            }, 1200);
          }
        }
      }
      
      // Continue with accepted tray modal
      fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
        .then(res => res.json())
        .then(rescanData => {
          if (rescanData.success) {
            showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
          }
        })
        .catch(error => {
          console.error('Error fetching accepted tray data:', error);
        });
        
    } else {
      if (msgDiv) {
        msgDiv.style.color = "#d32f2f";
        msgDiv.textContent = data.error || "Failed to save tray rejection";
      }
      if (proceedButton) proceedButton.disabled = false;
    }
  })
  .catch(() => {
    if (msgDiv) {
      msgDiv.style.color = "#d32f2f";
      msgDiv.textContent = "Network error";
    }
    if (proceedButton) proceedButton.disabled = false;
  });
}
      // ✅ NEW: Utility functions
      function showSuccessMessage(message, color = '#28a745') {
        const msgDiv = document.getElementById("batchRejectionMsg");
        if (msgDiv) {
          msgDiv.style.color = color;
          msgDiv.textContent = message;
          setTimeout(() => {
            msgDiv.textContent = "";
          }, 3000);
        }
      }

      function showErrorMessage(message) {
        const msgDiv = document.getElementById("batchRejectionMsg");
        if (msgDiv) {
          msgDiv.style.color = "#d32f2f";
          msgDiv.textContent = message;
          setTimeout(() => {
            msgDiv.textContent = "";
          }, 5000);
        }
      }


      
      // Helper function to get current lot ID
      function getCurrentLotId() {
        const modal = document.getElementById("trayScanModal");
        return modal?.dataset?.stockLotId || '';
      }

// ✅ ENHANCED: Update rejection scan counter with quantity tracking
function updateRejectionScanCounter() {
  const counter = document.getElementById('rejectionScanCounter');
  const status = document.getElementById('rejectionScanStatus');
  const progressBar = document.querySelector('#rejectionScanProgress > div');
  const distributionInfo = document.getElementById('trayDistributionInfo');
  const distributionDetails = document.getElementById('trayDistributionDetails');
  
  if (!counter) return;
  
  let totalRequiredScans = 0;
  let completedScans = 0;
  let distributionHTML = '';
  let shortageOnly = [];
  
  // Get current session allocations for better tracking
  const currentAllocations = collectCurrentSessionAllocations(null);
  
  console.log('🔄 [Counter Update] Current allocations:', currentAllocations);
  
  // Calculate total required scans and completed scans
  document.querySelectorAll('.rejection-qty-input').forEach(input => {
    const qty = parseInt(input.value) || 0;
    const row = input.closest('tr');
    const reasonCell = row.cells[2];
    const reasonText = reasonCell ? reasonCell.textContent.trim().toUpperCase() : '';
    const reasonId = input.getAttribute('data-reason-id');
    
    if (qty > 0 && reasonText !== 'SHORTAGE') {
      const trayIdCell = row.querySelector('td:last-child');
      const trayInputs = trayIdCell.querySelectorAll('.rejection-tray-id-input');
      
      // Calculate expected trays for this quantity
      const trayCapacity = getCurrentTrayCapacity();
      const expectedTrays = Math.ceil(qty / trayCapacity);
      totalRequiredScans += expectedTrays;
      
      // Find matching allocation for accurate count
      const matchingAllocation = currentAllocations.find(alloc => alloc.reason_id === reasonId);
      const actualCompletedTrays = matchingAllocation ? matchingAllocation.tray_count : 0;
      
      completedScans += actualCompletedTrays;
      
      // Enhanced distribution info
      let status = '';
      if (actualCompletedTrays === 0) {
        status = '⏳ Pending';
      } else if (actualCompletedTrays < expectedTrays) {
        status = `🔄 ${actualCompletedTrays}/${expectedTrays}`;
      } else {
        status = '✅ Complete';
      }
      
      distributionHTML += `
        <div style="margin-bottom: 4px; padding: 6px; border-radius: 4px; ${actualCompletedTrays === expectedTrays ? 'background-color: #d4edda;' : actualCompletedTrays > 0 ? 'background-color: #fff3cd;' : 'background-color: #f8d7da;'}">
          <span style="font-weight: 600; color: #007bff;">${reasonText}:</span>
          <span>Qty ${qty} → ${expectedTrays} tray${expectedTrays > 1 ? 's' : ''} ${status}</span>
        </div>
      `;
    } else if (qty > 0 && reasonText === 'SHORTAGE') {
      shortageOnly.push(`${reasonText}: ${qty}`);
    }
  });
  
  // Update distribution info
  if (distributionHTML) {
    distributionDetails.innerHTML = distributionHTML;
    distributionInfo.style.display = 'block';
  } else {
    distributionInfo.style.display = 'none';
  }
  
  // Update counter with enhanced information
  if (counter) {
    counter.textContent = `${completedScans}/${totalRequiredScans}`;
    
    // Enhanced color coding
    if (completedScans === totalRequiredScans && totalRequiredScans > 0) {
      counter.style.color = '#28a745'; // Green when complete
      counter.style.backgroundColor = '#d4edda';
    } else if (completedScans > 0) {
      counter.style.color = '#ffc107'; // Yellow when in progress  
      counter.style.backgroundColor = '#fff3cd';
    } else {
      counter.style.color = '#dc3545'; // Red when not started
      counter.style.backgroundColor = '#f8d7da';
    }
    
    counter.style.padding = '4px 8px';
    counter.style.borderRadius = '12px';
    counter.style.fontWeight = 'bold';
  }
  
  console.log(`🔄 [Counter Update] Total: ${completedScans}/${totalRequiredScans}`);
}

// ✅ REMOVE: Delete the old calculateCompleteTraysFromActualDistribution function
// This function is no longer needed with the simplified logic

console.log("✅ Simplified tray logic loaded - now supports:");
console.log("   • Qty 1-12 (with capacity 12): 1 tray");
console.log("   • Qty 13-24 (with capacity 12): 2 trays");
console.log("   • Qty 25-36 (with capacity 12): 3 trays");
console.log("   • etc.");

// ✅ NEW: Initialize enhanced counter
document.addEventListener('DOMContentLoaded', function() {
  updateRejectionScanCounter();
});


// ✅ HELPER: Get current tray capacity
function getCurrentTrayCapacity() {
  const currentRow = document.querySelector('tr.highlighted-tray-scan') || 
                     document.querySelector('[data-stock-lot-id]') ||
                     document.querySelector('tbody tr');
  
  if (currentRow) {
    const trayCapacityText = currentRow.cells[7]?.textContent || '';
    if (trayCapacityText.includes('-')) {
      return parseInt(trayCapacityText.split('-')[1]) || 12;
    }
  }
  
  return 12; // Default capacity
}

      // ✅ EXISTING: Handle batch rejection (unchanged)
      function handleBatchRejection(batchId, stockLotId) {
        const msgDiv = document.getElementById("batchRejectionMsg");
        const proceedButton = document.getElementById("proceedButton");
        const totalQty = document.getElementById('rejection-total-qty').textContent || "0";
        
        if (!batchId || !stockLotId) {
          if (msgDiv) msgDiv.textContent = "Batch ID or Lot ID not found.";
          if (proceedButton) proceedButton.disabled = false;
          return;
        }
        
        fetch('/inputscreening/batch_rejection/', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': getCookie('csrftoken')
          },
          body: JSON.stringify({
            batch_id: batchId,
            lot_id: stockLotId,
            total_qty: totalQty
          })
        })
        .then(res => res.json())
        .then(data => {
          if (data.success) {
            if (msgDiv) {
              msgDiv.style.color = "#388e3c";
              msgDiv.textContent = "Lot rejection saved!";
            }
            updateUIForBatchRejection(batchId);
            setTimeout(() => {
              trayModal.classList.remove("open");
              if (msgDiv) msgDiv.textContent = "";
              window.location.reload();
            }, 1200);
          } else {
            if (msgDiv) {
              msgDiv.style.color = "#d32f2f";
              msgDiv.textContent = data.error || "Failed to save batch rejection";
            }
            if (proceedButton) proceedButton.disabled = false;
          }
        })
        .catch(() => {
          if (msgDiv) {
            msgDiv.style.color = "#d32f2f";
            msgDiv.textContent = "Network error";
          }
          if (proceedButton) proceedButton.disabled = false;
        });
      }

      // ✅ NEW: Add redo functionality for rejection tray scan
      document.addEventListener('click', function(e) {
        if (e.target.id === 'rejectionTrayRedoBtn') {
          document.querySelectorAll('.rejection-tray-id-input').forEach(function(input) {
            input.value = '';
            const errorSpan = input.parentElement.querySelector('.rejection-tray-error');
            if (errorSpan) {
              errorSpan.style.display = 'none';
              errorSpan.textContent = '';
            }
          });
          updateRejectionScanCounter();
        }
      });



      // Function to fetch and show normal accepted tray data
      function fetchAndShowAcceptedTrayData(lotId) {
        fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(rescanData => {
            if (rescanData.success) {
              showAcceptedTrayModal(rescanData, lotId, false);
            }
          })
          .catch(error => {
          });
      }

      // Function to show read-only accepted tray data (for draft mode)
      function showReadOnlyAcceptedTrayData(lotId, detailsDiv) {
        fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(lotId)}`)
          .then(res => res.json())
          .then(data => {
            if (data.success && data.has_draft) {
              showAcceptedTrayModal(data, lotId, true);
            } else {
              // No draft exists, proceed with normal flow
              fetchAndShowAcceptedTrayData(lotId);
            }
          })
          .catch(error => {
            // Fallback to normal flow
            fetchAndShowAcceptedTrayData(lotId);
          });
      }

      // ✅ UPDATED: Modified showAcceptedTrayModal function - Remove "Set Top Tray" button
function showAcceptedTrayModal(rescanData, lotId, isDraft) {
  let modelNo = rescanData.model_no;
  let topTrayQty = rescanData.top_tray_qty; // ✅ NEW: Get from backend
  let draftTrayId = rescanData.draft_tray_id || ''; // ✅ NEW: Get draft data
  
  let draftIndicator = isDraft ? ' (Draft)' : '';
  let draftAlert = isDraft ? `
    <div class="alert alert-info" style="margin: 10px 0; padding: 8px 12px; font-size: 14px;">
      <i class="fa fa-info-circle"></i> This is draft data. You can edit and save changes.
    </div>
  ` : '';

  // ✅ UPDATED: Use actual backend data
  let html = `
    <div class="modal-top-header" style="display: flex; align-items: center; gap: 20px; padding-bottom: 10px;">
      <div class="user-profile" style="display: flex; align-items: center; gap: 8px">
        <img src="/static/assets/images/imagePlaceholder.png" alt="User Profile" style="border-radius: 50%; width: 50px; height: 50px; object-fit: cover;" />
        <span>Model No:</span>
        <h6>${modelNo} / Accepted Tray Rescan${draftIndicator}</h6>
      </div>
    </div>
    ${draftAlert}
    
    <!-- Delink Table -->
    <div id="delinkSection">

    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
      <h5 style="margin: 0; font-weight: 600; color: #595959;">Delink</h5>
      <div style="display: flex; align-items: center; gap: 15px;">
        <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="delinkTrayRedoBtn" style="width: 24px; height: 24px; cursor: pointer;" title="Clear Delink IDs" />
      
      </div>
    </div>

    <div class="table-responsive" style="margin-bottom: 20px; border: solid 1px black;">
      <table class="table table-bordered text-center" style="border: solid 2px black; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <thead style="background-color: #007bff; color: #fff;">
          <tr>
            <th style="padding: 12px;">S.No</th>
            <th style="padding: 12px;">De-Link Tray ID</th>
          </tr>
        </thead>
        <tbody id="delinkTableBody">
          <tr>
            <td colspan="3" style="padding: 20px;">
              <i class="fa fa-spinner fa-spin"></i> Loading delink data...
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    </div>
    
    <!-- ✅ UPDATED: Simplified Top Tray Scan Section - No "Set Top Tray" Button -->
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;">
      <h5 style="margin: 0; font-weight: 600; color:#595959">
        Accepted - Top Tray Scan${isDraft ? ' (Draft Mode)' : ''}
      </h5>
      <div style="display: flex; align-items: center; gap: 15px;">
        
        <img src="{% static 'assets/icons/redo2.png' %}" alt="Redo" id="topTrayRedoBtn" 
             style="width: 24px; height: 24px; cursor: pointer;" title="Clear Top Tray ID" />
      </div>
    </div>
    
    <!-- ✅ UPDATED: Simplified Top Tray Input without Set Button -->
    <div class="alert alert-info" style="margin-bottom: 15px; padding: 12px; border-left: 4px solid #007bff;">
      <i class="fa fa-info-circle"></i> <strong>Top Tray Scan Required</strong><br>
    </div>
    
    <div style="display: flex; align-items: center; gap: 15px; padding: 15px; border: 2px solid #e0e0e0; border-radius: 8px; background: #f9f9f9;">
      <div style="flex: 1;">
        <label style="font-weight: bold; margin-bottom: 5px; display: block;">Scan or enter top tray ID:</label>
        <input type="text" 
               id="topTrayIdInput" 
               placeholder="Scan Tray ID..." 
               value="${draftTrayId}"
               style="width: 300px; padding: 8px 12px; border: 2px solid #ddd; border-radius: 4px; font-size: 16px; ${draftTrayId ? 'background-color: #d4edda; border-color: #28a745;' : ''}" 
               class="top-tray-id-input" 
               ${(!isDraft && draftTrayId) } />
               <div id="topTrayError" style="color: #dc3545; font-size: 12px; margin-top: 4px; display: none;"></div>
      </div>
      
      <div style="text-align: center;">
        <label style="font-weight: bold; margin-bottom: 5px; display: block;">Tray Qty:</label>
        <input type="number" 
               value="${topTrayQty}" 
               readonly 
               style="width: 80px; padding: 8px; text-align: center; background: #f5f5f5; border: 1px solid #ccc; border-radius: 4px; font-weight: bold;" />
      </div>
    </div>
    
    <div style="margin-top: 10px; padding: 8px; background: #e7f3ff; border-radius: 4px; font-size: 12px;">
      <i class="fa fa-info-circle"></i> Only non-delinked tray IDs from this batch are valid
    </div>
    
    <!-- ✅ UPDATED: Action Buttons - Changed "Proceed" to "Submit" -->
    <div style="display: flex; justify-content: center; gap: 10px; margin-top: 30px;">
      ${isDraft ? `
        <button id="acceptedTrayUpdateDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
        <button id="acceptedTrayFinalSubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      ` : `
        <button id="acceptedTrayDraftBtn" style="padding: 8px 16px; background: #007bff; color: white; border: none; border-radius: 30px;">Draft</button>
        <button id="acceptedTraySubmitBtn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 30px;">Submit</button>
      `}
      <button id="acceptedTrayCancelBtn" style="padding: 8px 16px; background: #6c757d; color: white; border: none; border-radius: 30px;">Cancel</button>
    </div>
    
    <div id="acceptedTrayMsg" style="margin-top: 10px; text-align: center; font-weight: bold;"></div>
  `;
  
  document.querySelector("#newPopupModal .tray-scan-modal-content").innerHTML = html;
  newPopupModal.classList.add("open");
  
  
  // Load delink data
  loadDelinkTrayData(lotId);
  
  // Add event listeners
  addTopTrayEventListeners(lotId, isDraft, topTrayQty);
  
  // Show initial success message if draft exists
  if (draftTrayId) {
    showAcceptedTrayMessage('✅ Draft data loaded', '#28a745');
  }
  // Wait for delink tray inputs to be available in the DOM
  setTimeout(function() {
    if (rescanData.has_draft && rescanData.draft_tray_id) {
      // Set top tray ID
      const topTrayInput = document.getElementById('topTrayIdInput');
      if (topTrayInput) topTrayInput.value = rescanData.draft_tray_id;

      // Set delink tray ID and qty if present
      if (rescanData.delink_tray_id) {
        const delinkInput = document.querySelector('.delink-tray-input');
        if (delinkInput) delinkInput.value = rescanData.delink_tray_id;
        const delinkQtyInput = document.querySelector('.delink-tray-qty-input');
        if (delinkQtyInput) delinkQtyInput.value = rescanData.delink_tray_qty;
      }
    }
  }, 300); // Delay to ensure DOM is ready
}


      
      // ✅ UPDATED: Load delink tray data with scannable input fields
      function loadDelinkTrayData(lotId) {
        const delinkSection = document.getElementById('delinkSection');
        const url = `/inputscreening/get_delink_tray_data/?lot_id=${encodeURIComponent(lotId)}`;
     
        fetch(url)
          .then(res => {
            if (!res.ok) {
              throw new Error(`HTTP error! status: ${res.status}`);
            }
            return res.json();
          })
          .then(data => {
      
            // Hide or show the delink section based on tray count
            if (delinkSection) {
              if (data.delink_trays && data.delink_trays.length === 0) {
                delinkSection.style.display = 'none';
              } else {
                delinkSection.style.display = '';
              }
            }
      
            const tableBody = document.getElementById('delinkTableBody');
            const counter = document.getElementById('delinkScanCounter');
            if (!tableBody) {
              return;
            }
      
            if (data.success && data.delink_trays && data.delink_trays.length > 0) {
              
              // Calculate total quantity for counter
              let totalQty = data.delink_trays.reduce((sum, tray) => sum + (tray.tray_quantity || 0), 0);
      
              // Populate table with scannable input fields
              tableBody.innerHTML = '';
              data.delink_trays.forEach((tray, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                  <td>${tray.sno}</td>
                  <td>
                    <input type="text" 
                           class="form-control delink-tray-input" 
                           placeholder="Scan Tray ID for Delink" 
                           value=""
                           style="width: 120px;" 
                           data-row="${tray.sno}"
                           data-expected-qty="${tray.tray_quantity}" />
                    <span class="delink-tray-error" style="color: #d32f2f; font-size: 12px; display: none; margin-left: 4px;"></span>
                  </td>
            
                `;
                tableBody.appendChild(row);
              });
      
              // Update counter
              if (counter) {
                counter.textContent = `0/${totalQty}`;
                counter.style.color = '#dc3545'; // Red when not scanned
                counter.setAttribute('data-total-quantity', totalQty);
              }
      
              // Add delink tray validation
              addDelinkTrayValidation(lotId);
      
            } else if (data.success) {
              


              // No delink data available
              tableBody.innerHTML = `
                <tr>
                  <td colspan="3" style="padding: 20px; color: #6c757d; font-style: italic;">
                    <i class="fa fa-info-circle"></i> No trays available for delink
                  </td>
                </tr>
              `;
              if (counter) {
                counter.textContent = '0/0';
                counter.style.color = '#6c757d';
              }
            } else {
              // API returned error
              tableBody.innerHTML = `
                <tr>
                  <td colspan="3" style="padding: 20px; color: #dc3545;">
                    <i class="fa fa-exclamation-triangle"></i> Error: ${data.error}
                  </td>
                </tr>
              `;
            }
      
            // Call the redo functionality setup after DOM is ready
            setupDelinkRedoFunctionality();
          })
          .catch(error => {
            const tableBody = document.getElementById('delinkTableBody');
            if (tableBody) {
              tableBody.innerHTML = `
                <tr>
                  <td colspan="3" style="padding: 20px; color: #dc3545;">
                    <i class="fa fa-exclamation-circle"></i> Network error: ${error.message}
                  </td>
                </tr>
              `;
            }
            // Always hide delink section on error
            if (delinkSection) delinkSection.style.display = 'none';
          });
      }

      // ✅ NEW: Define the missing setupDelinkRedoFunctionality function
      function setupDelinkRedoFunctionality() {
        
        // Remove existing event listener if any
        const existingBtn = document.getElementById('delinkTrayRedoBtn');
        if (existingBtn) {
          existingBtn.removeEventListener('click', existingBtn._clickHandler);
        }
        
        // Add event listener for delink redo button
        const delinkRedoBtn = document.getElementById('delinkTrayRedoBtn');
        if (delinkRedoBtn) {
          const clickHandler = function() {
            
            // Clear all delink tray input values
            document.querySelectorAll('.delink-tray-input').forEach(function(input) {
              input.value = '';
              // Clear any error messages
              const errorSpan = input.parentElement.querySelector('.delink-tray-error');
              if (errorSpan) {
                errorSpan.style.display = 'none';
                errorSpan.textContent = '';
              }
            });
            
            // Update the delink scan counter
            updateDelinkScanCounter();
            
          };
          
          // Store reference for potential removal later
          delinkRedoBtn._clickHandler = clickHandler;
          delinkRedoBtn.addEventListener('click', clickHandler);
          
        } 
      }

      // ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
// ✅ UPDATED: Simplified event listeners without "Set Top Tray" button logic
function addTopTrayEventListeners(lotId, isDraft, topTrayQty) {
  const topTrayInput = document.getElementById('topTrayIdInput');
  const topTrayError = document.getElementById('topTrayError');
  const redoBtn = document.getElementById('topTrayRedoBtn');
  const counter = document.getElementById('topTrayScanCounter');
  
  // Input validation on blur - only for visual feedback, not blocking
  topTrayInput.addEventListener('blur', function() {
    const trayId = this.value.trim();
    if (!trayId || topTrayInput.readonly) {
      return;
    }
    
    // ✅ UPDATED: Only validate for visual feedback, don't block submission
    validateTopTrayIdForDisplay(trayId, lotId);
  });
  
  // Input change event
  topTrayInput.addEventListener('input', function() {
    if (topTrayInput.readonly) return;
    
    const trayId = this.value.trim();
    hideError();
    updateButtonStates(!!trayId); // Enable buttons when tray ID is entered
    updateCounter(!!trayId);
  });
  
  // Redo button
  if (redoBtn) {
    redoBtn.addEventListener('click', function() {
      topTrayInput.value = '';
      topTrayInput.readonly = false;
      topTrayInput.style.backgroundColor = '';
      topTrayInput.style.borderColor = '#ddd';
      hideError();
      updateButtonStates(false);
      updateCounter(false);
      topTrayInput.focus();
    });
      topTrayInput.addEventListener('input', checkForDuplicateTrayId);

  }
  
  // Button event listeners
  addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty);
  
  function validateTopTrayIdForDisplay(trayId, lotId) {
    showError('Validating...', '#007bff');
    
    fetch(`/inputscreening/check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
    .then(res => res.json())
    .then(data => {
      
      // Check for duplicate with delink trays
      let isDuplicate = false;
      const delinkInputs = document.querySelectorAll('.delink-tray-input');
      delinkInputs.forEach(input => {
        if (input.value.trim() && input.value.trim() === trayId) {
          isDuplicate = true;
        }
      });

      if (isDuplicate) {
        showError('❌ Same tray cannot be used for both Delink and Top Tray', '#dc3545');
        updateButtonStates(false);
        updateCounter(false);
        return;
      }

      if (data.error === 'Tray id is not verified' || data.tray_status === 'not_verified') {
          showError('❌ Tray id is not verified', '#dc3545');
          updateButtonStates(false);
          updateCounter(false);
          topTrayInput.style.backgroundColor = '#f8d7da';
          topTrayInput.style.borderColor = '#dc3545';
          return;
      }

      if (data.exists || data.already_used_in_acceptance) {
        showError('✅ Valid tray ID', '#28a745');
        updateButtonStates(true);
        updateCounter(true);
        topTrayInput.style.backgroundColor = '#d4edda';
        topTrayInput.style.borderColor = '#28a745';
        setTimeout(hideError, 2000);
        } else {
          // ❌ Only show error for genuinely invalid trays
          let errorMsg = 'Invalid tray ID';
          if (data.already_rejected) errorMsg = 'Tray already rejected';
          else if (data.not_in_same_lot) errorMsg = 'Tray not in same lot';
          else errorMsg = 'Tray ID not found';
          
          showError('❌ ' + errorMsg, '#dc3545');
          updateButtonStates(false);
          updateCounter(false);
          topTrayInput.style.backgroundColor = '#f8d7da';
          topTrayInput.style.borderColor = '#dc3545';
          
          // Auto-clear after 2 seconds
          setTimeout(() => {
            topTrayInput.value = '';
            topTrayInput.style.backgroundColor = '';
            topTrayInput.style.borderColor = '#ddd';
            hideError();
            updateButtonStates(false);
            updateCounter(false);
            topTrayInput.focus();
          }, 2000);
        }
      })
      .catch(error => {
        // ✅ UPDATED: Don't block on connection errors, just show warning
        showError('⚠️ Connection issue - will validate on submit', '#ffc107');
        updateButtonStates(true); // Allow submission anyway
        updateCounter(true);
      });
  }
  
  function updateButtonStates(hasValidTray) {
    const draftBtn = document.getElementById('acceptedTrayDraftBtn');
    const submitBtn = document.getElementById('acceptedTraySubmitBtn');
    const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
    const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
    
    if (draftBtn) draftBtn.disabled = !hasValidTray;
    if (submitBtn) submitBtn.disabled = !hasValidTray;
    if (updateDraftBtn) updateDraftBtn.disabled = !hasValidTray;
    if (finalSubmitBtn) finalSubmitBtn.disabled = !hasValidTray;
  }
  
  function updateCounter(isValid) {
    if (counter) {
      if (isValid) {
        counter.textContent = `${topTrayQty}/${topTrayQty}`;
        counter.style.color = '#28a745';
      } else {
        counter.textContent = `0/${topTrayQty}`;
        counter.style.color = '#dc3545';
      }
    }
  }
  
  function showError(message, color) {
    topTrayError.textContent = message;
    topTrayError.style.color = color;
    topTrayError.style.display = 'block';
  }
  
  function hideError() {
    topTrayError.style.display = 'none';
  }
}


// ✅ UPDATED: Button event listeners remain the same but now work directly with input validation
function addAcceptedTrayButtonListeners(lotId, isDraft, topTrayQty) {
  if (isDraft) {
    const updateDraftBtn = document.getElementById("acceptedTrayUpdateDraftBtn");
    const finalSubmitBtn = document.getElementById("acceptedTrayFinalSubmitBtn");
    
    if (updateDraftBtn) {
      updateDraftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
    }
    
    if (finalSubmitBtn) {
      finalSubmitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
    }
  } else {
    const draftBtn = document.getElementById("acceptedTrayDraftBtn");
    const submitBtn = document.getElementById("acceptedTraySubmitBtn");
    
    if (draftBtn) {
      draftBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, true));
    }
    
    if (submitBtn) {
      submitBtn.addEventListener("click", () => saveTopTrayScan(lotId, topTrayQty, false));
    }
  }
  
const cancelBtn = document.getElementById("acceptedTrayCancelBtn");
if (cancelBtn) {
  cancelBtn.addEventListener("click", () => {
    // Close the newPopupModal (accepted tray modal)
    document.getElementById("newPopupModal").classList.remove("open");
    
    // ✅ NEW: Also close trayScanModal if it's open
    const trayScanModal = document.getElementById("trayScanModal");
    if (trayScanModal && trayScanModal.classList.contains("open")) {
      trayScanModal.classList.remove("open");
      trayScanModal.style.display = "none";
    }
    
    // Add a slight delay then refresh table data only
    setTimeout(() => {
      refreshTableData();
    }, 300);
  });
}
}

function refreshTableData() {
  // Get current page number for pagination
  const currentPage = new URLSearchParams(window.location.search).get('page') || 1;

  // Fetch fresh table data silently
  fetch(`${window.location.pathname}?page=${currentPage}`, {
    method: 'GET',
    headers: {
      'X-Requested-With': 'XMLHttpRequest', // Mark as AJAX request
    }
  })
  .then(response => response.text())
  .then(html => {
    // Create a temporary container to parse the response
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;

    // Extract the new table content
    const newTableBody = tempDiv.querySelector('#order-listing tbody');
    const currentTableBody = document.querySelector('#order-listing tbody');

    if (newTableBody && currentTableBody) {
      // Replace table body content silently
      currentTableBody.innerHTML = newTableBody.innerHTML;

      // Also update pagination if needed
      const newPagination = tempDiv.querySelector('.pagination-wrapper');
      const currentPagination = document.querySelector('.pagination-wrapper');
      if (newPagination && currentPagination) {
        currentPagination.innerHTML = newPagination.innerHTML;
      }

      // ✅ Re-attach modal open event listeners after table refresh

      // ✅ FIXED: Reject button with proper conditional logic
      document.querySelectorAll('.tray-scan-btn').forEach((link) => {
        link.addEventListener('click', (event) => {
          event.preventDefault();

          const row = event.target.closest("tr");
          const batchId = link.getAttribute('data-batch-id');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          
          // ✅ Get the row attributes to determine which modal to show
          const ipOnholdPicking = row.getAttribute('data-ip-onhold-picking') === 'True';
          const fewCasesAcceptance = row.getAttribute('data-few-cases-acceptance') === 'True';

          console.log('Reject button clicked:', {
            ipOnholdPicking,
            fewCasesAcceptance,
            stockLotId
          });

          // ✅ Apply the correct conditional logic
          if (ipOnholdPicking && fewCasesAcceptance) {
            // Both are true - show accepted tray modal (Partial Reject scenario)
            console.log('Both conditions true - showing accepted tray modal');
            fetch(`/inputscreening/get_accepted_tray_scan_data/?lot_id=${encodeURIComponent(stockLotId)}`)
              .then(res => res.json())
              .then(rescanData => {
                if (rescanData.success) {
                  showAcceptedTrayModal(rescanData, stockLotId, rescanData.has_draft || false);
                } else {
                  // Fallback to showing rejection modal if accepted tray data fails
                  showRejectionModalFlow(batchId, stockLotId, true, row);
                }
              })
              .catch(error => {
                console.error('Error fetching accepted tray data:', error);
                // Fallback to showing rejection modal
                showRejectionModalFlow(batchId, stockLotId, true, row);
              });
          } else {
            // Either both are false or only ipOnholdPicking is true - show rejection modal
            console.log('Showing rejection modal flow');
            
            // ✅ FIXED: Use the same logic as original event listener
            // Set up the modal data first
            const trayModal = document.getElementById("trayScanModal");
            const detailsDiv = document.getElementById("trayScanDetails");
            const modalHeader = document.getElementById("trayScanModalHeader");
            
            trayModal.dataset.batchId = batchId;
            trayModal.dataset.stockLotId = stockLotId;
            
            // Set modal header
            const modelNo = row.getAttribute('data-model-no') || '';
            if (modalHeader) {
              modalHeader.innerHTML = `Input Screening / <span class="modal-model-no">${modelNo}</span> / Rejection Window`;
            }
            
            // ✅ CRITICAL: Use the same conditional logic as original
            if (ipOnholdPicking) {
              // Show read-only saved data (completed process)
              showEditableRejectionFormWithData(stockLotId, batchId, detailsDiv, row, null);
            } else {
              // ✅ FIXED: Check for draft first, then show form
              checkForExistingDraft(stockLotId, batchId, detailsDiv, row);
            }
            
            // Show the modal
            trayModal.style.display = "block";
            trayModal.classList.add("open");
          }
        });
      });

      // View button (opens Input Screening modal - right side)
      document.querySelectorAll('.tray-scan-btn-DayPlanning-view').forEach((link) => {
        link.addEventListener('click', async function (e) {
          e.preventDefault();

          // Get modal elements
          const modal = document.getElementById("trayScanModal_DayPlanning");
          const detailsDiv = document.getElementById("trayScanDetails_DayPlanning");
          const modalModelNo = document.getElementById("modalModelNo_DayPlanning");
          modal.dataset.batchId = link.getAttribute('data-batch-id');

          // Get data attributes
          const batchId = link.getAttribute('data-batch-id');
          const stockLotId = link.getAttribute('data-stock-lot-id');
          const modelNo = link.getAttribute('data-model-no');
          const noOfTrays = parseInt(link.getAttribute('data-no-of-trays')) || 0;
          const trayCapacity = link.getAttribute('data-tray-capacity') || "";
          const isQtyVerified = link.getAttribute('data-ip-person-qty-verified') === 'true';

          let trayQtyList = [];
          try {
            trayQtyList = JSON.parse(link.getAttribute('data-tray-qty-list') || "[]");
          } catch (e) {
            trayQtyList = [];
          }

          // Set model number in modal
          if (modalModelNo && modelNo) {
            modalModelNo.textContent = modelNo;
          }

          // Set model image
          const modalUserImg = modal.querySelector('.user-profile img');
          const modelImage = link.getAttribute('data-model-image');
          if (modalUserImg) {
            if (modelImage) {
              modalUserImg.src = modelImage;
            } else {
              modalUserImg.src = "/static/assets/images/imagePlaceholder.png";
            }
          }

          // Show/Hide validation buttons based on verification status
          const trayValidateSection = document.getElementById("trayValidateSection");
          const verificationStatusIndicator = document.getElementById("verificationStatusIndicator");

          if (isQtyVerified) {
            if (trayValidateSection) trayValidateSection.style.display = "none";
            if (verificationStatusIndicator) verificationStatusIndicator.style.display = "block";
          } else {
            if (trayValidateSection) trayValidateSection.style.display = "flex";
            if (verificationStatusIndicator) verificationStatusIndicator.style.display = "none";
          }

          // Fetch tray data with proper top tray handling using API
          let traysData = [];
          try {
            const resp = await fetch(`/inputscreening/ip_completed_tray_id_list/?batch_id=${encodeURIComponent(batchId)}`);
            const result = await resp.json();
            if (result.success && Array.isArray(result.trays) && result.trays.length > 0) {
              traysData = result.trays;
            }
          } catch (e) {
          }

          // Fetch existing verification status
          let verificationData = {};
          try {
            const verifyResp = await fetch(`/inputscreening/get_tray_verification_status/?lot_id=${encodeURIComponent(stockLotId)}`);
            const verifyResult = await verifyResp.json();
            if (verifyResult.success) {
              verificationData = verifyResult.verification_data;
            }
          } catch (e) {
          }

          // TABLE BUILDING FUNCTION (reuse your existing buildTableHTML)
          function buildTableHTML(showValidationColumn = false) {
            let html = `
              <table class="table table-bordered table-sm" style="width:100%; margin-bottom:0;">
                <thead>
                  <tr>
                    <th style="width:50px;">S.no</th>
                    <th>Tray ID</th>
                    <th>Tray Qty</th>
                    ${showValidationColumn && !isQtyVerified ? '<th>Tray Validation Status</th>' : ''}
                  </tr>
                </thead>
                <tbody>
            `;
            
            // If we have trays data from API, use it directly
            if (traysData && traysData.length > 0) {
              traysData.forEach((tray, index) => {
                const isTopTray = tray.is_top_tray || index === 0;
                const displaySNo = tray.is_top_tray ? '1 (Top Tray)' : tray.s_no;
                const position = index + 1;

                // Check verification status
                const verification = verificationData[position];
                const isVerifiedByUser = verification ? verification.is_verified : false;
                const isVerifiedInDB = tray.IP_tray_verified || false;
                const isVerified = isVerifiedByUser || isVerifiedInDB;
                
                const verificationStatus = verification ? verification.verification_status : null;
                const verifiedTrayId = verification ? verification.tray_id : '';

                // Set input properties based on verification status
                let inputValue, inputStyle, verificationIndicator;

                if (isVerified) {
                  inputValue = verifiedTrayId || tray.tray_id || '';
                  inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                  verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
                } else {
                  inputValue = tray.tray_id || '';
                  inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                  verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
                }

                html += `
                  <tr>
                    <td>${displaySNo}</td>
                    <td>
                      <input type="text" 
                             class="form-control" 
                             value="${inputValue}" 
                             readonly 
                             style="${inputStyle}"
                             data-position="${position}" />
                      ${verificationIndicator}
                    </td>
                    <td style="position:relative; white-space:nowrap;">
                      <span style="display:inline-flex; align-items:center;">
                        <input type="number" 
                               class="form-control tray-qty-input" 
                               value="${tray.tray_quantity || ''}" 
                               readonly 
                               style="width: 40px; display:inline-block; vertical-align:middle; text-align:right; margin-right:4px;"
                               data-initial="${tray.tray_quantity || ''}"
                               ${isTopTray ? 'data-top-tray="1"' : ''} 
                        />
                       
                      </span>
                    </td>
                    ${showValidationColumn && !isQtyVerified ? `
                      <td>
                        <div class="validation-status">
                          <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                            <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                          </div>
                          <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                            <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                          </div>
                        </div>
                      </td>
                    ` : ''}
                  </tr>
                `;
              });
            } else {
              // Fallback: Use the old method if API data is not available
              let totalRows = noOfTrays;
              for (let i = 0; i < totalRows; i++) {
                const position = i + 1;
                const verification = verificationData[position];
                const isVerified = verification ? verification.is_verified : false;
                const verificationStatus = verification ? verification.verification_status : null;
                const verifiedTrayId = verification ? verification.tray_id : '';
                const trayQty = trayQtyList[i] || trayCapacity;
                
                let inputValue, inputStyle, verificationIndicator;
                
                if (isVerified) {
                  inputValue = verifiedTrayId;
                  inputStyle = 'width: 100%; background-color: #f5f5f5; border-color: #28a745; color: #155724;';
                  verificationIndicator = '<small style="color: #28a745; font-weight: bold;">✓ Verified</small>';
                } else {
                  inputValue = '';
                  inputStyle = 'width: 100%; background-color: #fff3cd; border-color: #ffc107;';
                  verificationIndicator = '<small style="color: #856404; font-weight: bold;">⏳ Not Verified</small>';
                }
                
                html += `
                  <tr>
                    <td>${i === 0 ? '1 (Top Tray)' : (i + 1)}</td>
                    <td>
                      <input type="text" 
                             class="form-control" 
                             value="${inputValue}" 
                             readonly 
                             style="${inputStyle}"
                             data-position="${position}" />
                      ${verificationIndicator}
                    </td>
                    <td>
                      <input type="number" class="form-control" value="${trayQty}" readonly style="width: 100%;" />
                    </td>
                    ${showValidationColumn && !isQtyVerified ? `
                      <td>
                        <div class="validation-status">
                          <div class="status-icon fail ${!isVerified ? '' : (verificationStatus === 'fail' ? 'active' : 'inactive')}">
                            <img src="/static/assets/icons/fail.png" alt="Fail" title="Fail" style="width:18px; height:18px;" />
                          </div>
                          <div class="status-icon pass ${!isVerified ? '' : (verificationStatus === 'pass' ? 'active' : 'inactive')}">
                            <img src="/static/assets/icons/pass.png" alt="Pass" title="Pass" style="width:18px; height:18px;" />
                          </div>
                        </div>
                      </td>
                    ` : ''}
                  </tr>
                `;
              }
            }
            
            html += `
                </tbody>
              </table>
            `;
            return html;
          }

          // Initially show table
          detailsDiv.innerHTML = buildTableHTML(false);

          // Store data in modal for later use
          modal.buildTableHTML = buildTableHTML;
          modal.traysData = traysData;
          modal.verificationData = verificationData;
          modal.noOfTrays = noOfTrays;
          modal.trayQtyList = trayQtyList;
          modal.trayCapacity = trayCapacity;
          modal.isQtyVerified = isQtyVerified;
          modal.stockLotId = stockLotId;

          // Show the modal
          if (modal) modal.style.display = "block";
          modal.classList.add("open");

          // Check verification status after modal opens
          setTimeout(() => {
            if (!modal.isQtyVerified) {
              checkVerificationStatusAndShowButtons();
            } else {
              removeDraftCancelButtons();
            }
          }, 200);
        });
      });

      // ✅ Re-attach Hold Toggle functionality after table refresh
      console.log('Calling attachHoldToggleListeners after table refresh...');
      if (typeof attachHoldToggleListeners === 'function') {
        attachHoldToggleListeners();
      } else {
        console.error('attachHoldToggleListeners function not found!');
      }

      // Re-attach other event listeners if needed (accept buttons, delete buttons, etc.)
      reattachOtherEventListeners();
    }
  })
  .catch(error => {
    console.error('Error refreshing table data:', error);
    // Silent error - no user notification
  });
}

// Helper function to reattach other event listeners
function reattachOtherEventListeners() {
  // Re-attach Accept button listeners
  document.addEventListener('click', function(e) {
    if (e.target.closest('.btn-twitter')) {
      // Your existing accept button logic here
    }
  });

  // Re-attach Delete button listeners
  document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      // Your existing delete button logic here
    });
  });

  // Re-attach any other dynamic event listeners as needed
}
// Helper function to reattach other event listeners
function reattachOtherEventListeners() {
  // Re-attach Accept button listeners
  document.addEventListener('click', function(e) {
    if (e.target.closest('.btn-twitter')) {
      // Your existing accept button logic here
    }
  });

  // Re-attach Delete button listeners
  document.querySelectorAll('.delete-batch-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      // Your existing delete button logic here
    });
  });

  // Re-attach any other dynamic event listeners as needed
}

// ✅ FIXED: Modified saveTopTrayScan to work without redundant frontend validation
function saveTopTrayScan(lotId, topTrayQty, isDraft) {
  
  const topTrayInput = document.getElementById('topTrayIdInput');
  const trayId = topTrayInput ? topTrayInput.value.trim() : '';

  
  if (!trayId) {
    showAcceptedTrayMessage('Please scan a tray ID first', '#dc3545');
    return;
  }
  
  // ✅ FIXED: Remove redundant frontend validation since backend already validates
  // Directly proceed with save - backend will handle all validation
  proceedWithSave();
  
  function proceedWithSave() {
    // ✅ NEW: Collect delink tray data with detailed logging
    const delinkTrays = [];
    const delinkInputs = document.querySelectorAll('.delink-tray-input');
    
    
    delinkInputs.forEach((input, index) => {
      const delinkTrayId = input.value.trim();
      const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
      

      
      if (delinkTrayId) {
        delinkTrays.push({
          tray_id: delinkTrayId,
          tray_qty: expectedQty
        });
      }
    });
    
    
    // ✅ UPDATED: Allow same tray ID for both delink and top tray scan
    // Removed validation that prevented duplicate tray IDs
    
    // ✅ UPDATED: More flexible validation for proceed operations
    if (!isDraft) {
      // Check if there are delink inputs that should be filled
      const totalDelinkInputs = delinkInputs.length;
      const filledDelinkInputs = delinkTrays.length;
      

      
      // ✅ UPDATED: Allow submission even if delink trays are not filled
      // This is now optional - user can proceed with just top tray scan
    }
    
    const payload = {
      lot_id: lotId,
      tray_id: trayId,
      tray_qty: topTrayQty,
      draft_save: isDraft,
      delink_trays: delinkTrays
    };
    
    
    // ✅ NEW: Show appropriate loading message
    if (!isDraft) {
      if (delinkTrays.length > 0) {
        showAcceptedTrayMessage(`⏳ Processing top tray scan and ${delinkTrays.length} delink operations...`, '#007bff');
      } else {
        showAcceptedTrayMessage('⏳ Processing top tray scan...', '#007bff');
      }
    } else {
      showAcceptedTrayMessage('⏳ Saving draft...', '#007bff');
    }
    
    fetch('/inputscreening/save_single_top_tray_scan/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCookie('csrftoken')
      },
      body: JSON.stringify(payload)
    })
    .then(res => {
      return res.json();
    })
    .then(data => {
      
      if (data.success) {
        let message = data.message;
        
        // ✅ NEW: Show detailed success message
        if (!isDraft && data.delink_count > 0) {
          message = `✅ Top tray scan completed. ${data.delink_count} tray(s) marked for delink.`;
        } else if (!isDraft) {
          message = '✅ Top tray scan completed successfully.';
        } else {
          message = '✅ Draft saved successfully.';
        }
        
        showAcceptedTrayMessage(message, '#28a745');

        setTimeout(() => {
          window.location.reload();
        }, 1500);

        return;
        
        if (!isDraft) {
          // Close modal and refresh page after successful final submit
          setTimeout(() => {
            document.getElementById("newPopupModal").classList.remove("open");
            location.reload();
          }, 2000);
        }
      } else {
        showAcceptedTrayMessage(data.error || 'Failed to save', '#dc3545');
      }
    })
    .catch(error => {
      showAcceptedTrayMessage('Network error occurred', '#dc3545');
    });
  }
}

// ✅ EXISTING: Show message helper
      function showAcceptedTrayMessage(message, color) {
        const msgDiv = document.getElementById("acceptedTrayMsg");
        if (msgDiv) {
          msgDiv.style.color = color;
          msgDiv.textContent = message;
          setTimeout(() => {
            msgDiv.textContent = "";
          }, 3000);
        }
      }

      // ✅ UPDATED: Enhanced delink tray validation - Allow same tray ID as top tray
function addDelinkTrayValidation(lotId) {
  
  document.querySelectorAll('.delink-tray-input').forEach(function(input, idx, allInputs) {
    // Remove existing event listeners
    if (input._blurHandler) input.removeEventListener('blur', input._blurHandler);
    if (input._inputHandler) input.removeEventListener('input', input._inputHandler);
    if (input._keydownHandler) input.removeEventListener('keydown', input._keydownHandler);
    
    // Track validation state for each input
    input._hasError = false;
    input._isValidating = false;
    
    // Input event for counter update
    input._inputHandler = function() {
      // Clear error state when user starts typing
      this._hasError = false;
      const errorSpan = this.parentElement.querySelector('.delink-tray-error');
      if (errorSpan) {
        errorSpan.style.display = 'none';
        errorSpan.textContent = '';
      }
      updateDelinkScanCounter();
    };
    input.addEventListener('input', input._inputHandler);
    
    // Enhanced keydown handler to prevent navigation on errors
    input._keydownHandler = function(e) {
      if (e.key === 'Enter') {
        e.preventDefault();
        
        // Prevent navigation if current field has error
        if (this._hasError) {
          this.focus(); // Keep focus on current field
          return;
        }
        
        // Prevent navigation if currently validating
        if (this._isValidating) {
          return;
        }
        
        // Prevent navigation if field is empty
        if (!this.value.trim()) {
          return;
        }
        
        // Allow navigation - move to next field only if no errors
        const nextInput = allInputs[idx + 1];
        if (nextInput) {
          nextInput.focus();
        }
      }
    };
    input.addEventListener('keydown', input._keydownHandler);
    
    // Blur event for validation
    input._blurHandler = function() {
      const trayId = this.value.trim();
      const errorSpan = this.parentElement.querySelector('.delink-tray-error');
      
      // Reset error state
      this._hasError = false;
      
      if (errorSpan) {
        errorSpan.textContent = '';
        errorSpan.style.display = 'none';
        errorSpan.className = 'delink-tray-error';
      }
      
      if (!trayId) {
        updateDelinkScanCounter();
        return;
      }

      // Set validating state
      this._isValidating = true;

      // ✅ UPDATED: Check for duplicate tray ID in other DELINK rows only
      // No longer check against top tray ID
      let duplicateRow = null;
      allInputs.forEach(function(otherInput, otherIdx) {
        if (otherIdx !== idx && otherInput.value.trim() === trayId) {
          duplicateRow = otherInput.dataset.row;
        }
      });
      
      if (duplicateRow) {
        this._hasError = true;
        this._isValidating = false;
        
        if (errorSpan) {
          errorSpan.innerHTML = `❌ Duplicate in delink row ${duplicateRow}`;
          errorSpan.className = 'delink-tray-error error-status';
          errorSpan.style.display = 'block';
          errorSpan.style.color = '#dc3545';
          errorSpan.style.backgroundColor = '#f8d7da';
          errorSpan.style.padding = '4px 8px';
          errorSpan.style.borderRadius = '4px';
          errorSpan.style.marginTop = '4px';
        }
        
        // Auto-clear the input after showing error
        setTimeout(() => {
          this.value = '';
          this._hasError = false;
          if (errorSpan) {
            errorSpan.style.display = 'none';
          }
          this.focus(); // Keep focus on current field
          updateDelinkScanCounter();
        }, 800);
        
        updateDelinkScanCounter();
        return;
      }

      // Server check for delink tray validation
      fetch(`/inputscreening/delink_check_tray_id/?tray_id=${encodeURIComponent(trayId)}&lot_id=${encodeURIComponent(lotId)}`)
        .then(res => res.json())
        .then(data => {
          this._isValidating = false; // Clear validating state
          
          if (errorSpan) {
            if (data.exists && data.valid_for_delink) {
              // Success: Show green available status
              this._hasError = false;
              errorSpan.innerHTML = `✅ ${data.status_message}`;
              errorSpan.className = 'delink-tray-error success-status';
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#155724';
              errorSpan.style.backgroundColor = '#d4edda';
              errorSpan.style.padding = '4px 8px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.marginTop = '4px';
              
              // Auto-hide success message
              setTimeout(() => {
                if (errorSpan) {
                  errorSpan.style.display = 'none';
                }
              }, 1000);
              
            } else {
              // Error: Show red error status with specific messages
              this._hasError = true;
              let errorMessage = `❌ ${data.status_message || data.error}`;
              
              errorSpan.innerHTML = errorMessage;
              errorSpan.className = 'delink-tray-error error-status';
              errorSpan.style.display = 'block';
              errorSpan.style.color = '#721c24';
              errorSpan.style.backgroundColor = '#f8d7da';
              errorSpan.style.padding = '4px 8px';
              errorSpan.style.borderRadius = '4px';
              errorSpan.style.marginTop = '4px';
              
              // Auto-clear the input after showing error
              setTimeout(() => {
                this.value = '';
                this._hasError = false;
                if (errorSpan) {
                  errorSpan.style.display = 'none';
                }
                this.focus(); // Keep focus on current field
                updateDelinkScanCounter();
              }, 1000);
            }
          }
          updateDelinkScanCounter();
        })
        .catch((error) => {
          this._isValidating = false; // Clear validating state
          this._hasError = true;
          
          if (errorSpan) {
            errorSpan.innerHTML = '❌ Connection Error';
            errorSpan.className = 'delink-tray-error error-status';
            errorSpan.style.display = 'block';
            errorSpan.style.color = '#721c24';
            errorSpan.style.backgroundColor = '#f8d7da';
            errorSpan.style.padding = '4px 8px';
            errorSpan.style.borderRadius = '4px';
            errorSpan.style.marginTop = '4px';
            
            // Auto-clear the input after showing error
            setTimeout(() => {
              this.value = '';
              this._hasError = false;
              if (errorSpan) {
                errorSpan.style.display = 'none';
              }
              this.focus(); // Keep focus on current field
              updateDelinkScanCounter();
            }, 1000);
          }
          updateDelinkScanCounter();
        });
    };
    input.addEventListener('blur', input._blurHandler);
    
  });
  
// After all delink-tray-inputs are created and event listeners are set up:
  document.querySelectorAll('.delink-tray-input').forEach(input => {
    input.addEventListener('input', checkForDuplicateTrayId);
  });

} 

// Place this function after both above functions:
function checkForDuplicateTrayId() {
  const topTrayInput = document.getElementById('topTrayIdInput');
  const delinkInputs = document.querySelectorAll('.delink-tray-input');
  const submitBtn = document.getElementById('acceptedTraySubmitBtn');
  const draftBtn = document.getElementById('acceptedTrayDraftBtn');
  const updateDraftBtn = document.getElementById('acceptedTrayUpdateDraftBtn');
  const finalSubmitBtn = document.getElementById('acceptedTrayFinalSubmitBtn');
  const errorDiv = document.getElementById('topTrayError');
  let duplicate = false;

  if (topTrayInput && topTrayInput.value.trim()) {
    delinkInputs.forEach(input => {
      if (input.value.trim() && input.value.trim() === topTrayInput.value.trim()) {
        duplicate = true;
      }
    });
  }

  if (duplicate) {
    if (submitBtn) submitBtn.disabled = true;
    if (draftBtn) draftBtn.disabled = true;
    if (updateDraftBtn) updateDraftBtn.disabled = true;
    if (finalSubmitBtn) finalSubmitBtn.disabled = true;
    if (errorDiv) {
      errorDiv.textContent = '❌ Same tray cannot be used for both Delink and Top Tray';
      errorDiv.style.display = 'block';
      errorDiv.style.color = '#dc3545';
    }
  } else {
    if (submitBtn) submitBtn.disabled = false;
    if (draftBtn) draftBtn.disabled = false;
    if (updateDraftBtn) updateDraftBtn.disabled = false;
    if (finalSubmitBtn) finalSubmitBtn.disabled = false;
    if (errorDiv) errorDiv.style.display = 'none';
  }
}

      // ✅ NEW: Update delink scan counter
      function updateDelinkScanCounter() {
        const counter = document.getElementById('delinkScanCounter');
        if (!counter) return;
        
        const totalQuantity = parseInt(counter.getAttribute('data-total-quantity')) || 0;
        let scannedQuantity = 0;
        
        // Calculate total scanned quantity
        document.querySelectorAll('.delink-tray-input').forEach(input => {
          const trayId = input.value.trim();
          const hasError = input.parentElement.querySelector('.delink-tray-error').style.display === 'block';
          
          // Only count if tray ID is filled and has no errors
          if (trayId && !hasError) {
            // Get the expected quantity for this row
            const expectedQty = parseInt(input.getAttribute('data-expected-qty')) || 0;
            scannedQuantity += expectedQty;
          }
        });
        
        // Update counter display
        counter.textContent = `${scannedQuantity}/${totalQuantity}`;
        
        // Update color based on progress
        if (scannedQuantity === totalQuantity && totalQuantity > 0) {
          counter.style.color = '#28a745'; // Green when complete
        } else if (scannedQuantity > 0) {
          counter.style.color = '#ffc107'; // Yellow when in progress
        } else {
          counter.style.color = '#dc3545'; // Red when not started
        }
        
      }

      // Helper function to get CSRF token
      function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
          const cookies = document.cookie.split(';');
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
              cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
              break;
            }
          }
        }
        return cookieValue;
      }

      // ✅ MISSING FUNCTIONS: Add the missing utility functions
      function updateUIForBatchRejection(batchId) {
        // Update UI after batch rejection if needed
      }

      
      trayModal.addEventListener("click", (event) => {
        if (event.target === trayModal) {
          trayModal.classList.remove("open");
        }
      });
      
      // New Popup Modal close events
      closeNewPopupBtn.addEventListener("click", () => {
        newPopupModal.classList.remove("open");
      });
     
    });

    // ✅ NEW: Add CSS for draft mode animations and grid styling
    const draftModeCSS = `
      <style>
        @keyframes draftModeGlow {
          from { box-shadow: 0 0 5px rgba(243, 156, 18, 0.3); }
          to { box-shadow: 0 0 15px rgba(243, 156, 18, 0.6); }
        }
        
        .row-has-draft {
          background-color: #fff3cd !important;
          border-left: 4px solid #f39c12 !important;
        }
        
        .table-grid {
          display: grid;
          grid-template-columns: auto 1fr auto;
          gap: 0;
        }
        
        .table-grid > div {
          border: 1px solid #ccc;
          padding: 8px;
          background: #fff;
        }
        
        .table-grid > div:first-child,
        .table-grid > div:nth-child(3n+1) {
          background: #f8f9fa;
          font-weight: bold;
        }
        
        /* Enhanced styling for single top tray scan */
        .top-tray-input-section {
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          background: #f9f9f9;
          padding: 15px;
          margin: 15px 0;
        }
        
        .top-tray-input-section.has-value {
          border-color: #28a745;
          background: #f8fff9;
        }
        
        .top-tray-input-section.has-error {
          border-color: #dc3545;
          background: #fff5f5;
        }
        
        .scan-counter {
          background: #f8f9fa;
          padding: 6px 12px;
          border-radius: 20px;
          border: 1px solid #dee2e6;
          font-size: 14px;
          font-weight: 600;
        }
        
        .scan-counter.complete {
          background: #d4edda;
          border-color: #28a745;
          color: #155724;
        }
        
        .scan-counter.progress {
          background: #fff3cd;
          border-color: #ffc107;
          color: #856404;
        }
        
        .scan-counter.pending {
          background: #f8d7da;
          border-color: #dc3545;
          color: #721c24;
        }
        
        /* Button styling improvements */
        .action-button {
          padding: 8px 16px;
          border: none;
          border-radius: 30px;
          font-weight: 500;
          transition: all 0.3s ease;
          cursor: pointer;
        }
        
        .action-button:hover:not(:disabled) {
          transform: translateY(-1px);
          box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        
        .action-button:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
        
        /* Error and success message styling */
        .status-message {
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          margin-top: 4px;
          display: inline-block;
        }
        
        .status-message.success {
          color: #155724;
          background-color: #d4edda;
          border: 1px solid #c3e6cb;
        }
        
        .status-message.error {
          color: #721c24;
          background-color: #f8d7da;
          border: 1px solid #f5c6cb;
        }
        
        /* Loading spinner */
        .loading-spinner {
          display: inline-block;
          width: 16px;
          height: 16px;
          border: 2px solid #f3f3f3;
          border-top: 2px solid #007bff;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        /* Responsive improvements */
        @media (max-width: 768px) {
          .top-tray-input-section {
            flex-direction: column;
            gap: 10px;
          }
          
          .top-tray-input-section > div {
            width: 100% !important;
          }
          
          .scan-counter {
            font-size: 12px;
            padding: 4px 8px;
          }
        }
      </style>
    `;
    
    document.head.insertAdjacentHTML('beforeend', draftModeCSS);
  </script>

<script nonce="{{ csp_nonce }}">
    document.addEventListener("DOMContentLoaded", function () {
      var triggers = document.querySelectorAll(".remark-tooltip-trigger");
      triggers.forEach(function (trigger) {
        var tooltip = trigger.querySelector(".remark-tooltip");
        var sendButton = tooltip ? tooltip.querySelector("button") : null;
        function showTooltip() {
          tooltip.style.opacity = "1";
          tooltip.style.visibility = "visible";
          var rect = tooltip.getBoundingClientRect();
          if (rect.right > window.innerWidth) {
            tooltip.style.left = "auto";
            tooltip.style.right = "0";
            tooltip.style.transform = "none";
          }
          if (rect.left < 0) {
            tooltip.style.left = "0";
            tooltip.style.transform = "none";
          }
          var textarea = tooltip.querySelector("textarea");
          if (textarea) {
            textarea.focus();
          }
        }
        function hideTooltip() {
          tooltip.style.opacity = "0";
          tooltip.style.visibility = "hidden";
        }
        trigger.addEventListener("mouseenter", showTooltip);
        trigger.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!trigger.matches(":hover") && !tooltip.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        tooltip.addEventListener("mouseleave", function () {
          setTimeout(function () {
            if (!tooltip.matches(":hover") && !trigger.matches(":hover")) {
              hideTooltip();
            }
          }, 100);
        });
        trigger.addEventListener("click", function (e) {
          e.preventDefault();
        });
        if (sendButton) {
          sendButton.addEventListener("click", function (e) {
            e.preventDefault();
            // Find the textarea and get its value
            var textarea = tooltip.querySelector("textarea");
            var remark = textarea ? textarea.value.trim() : "";
            if (!remark) {
              Swal.fire('Error', 'Please enter a remark before sending.', 'error');
              return;
            }
            // Find the batch_id from the row (tr) data attribute or from a hidden field
            var row = trigger.closest("tr");
            var trayScanLink = row ? row.querySelector('.tray-scan-btn') : null;
            var batchId = row ? row.getAttribute('data-batch-id') : null;
            if (!batchId) {
              Swal.fire('Error', 'Batch ID not found.', 'error');
              return;
            }
            fetch('/inputscreening/save_ip_pick_remark/', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
              },
              body: JSON.stringify({
                batch_id: batchId,
                remark: remark
              })
            })
            .then(res => res.json())
            .then(data => {
              if (data.success) {
                Swal.fire({
                  icon: 'success',
                  title: 'Remark saved!',
                  timer: 1200,
                  showConfirmButton: false
                }).then(() => {
                  // Make the textarea readonly
                  if (textarea) {
                    textarea.setAttribute("readonly", true);
                  }

                  // Replace send button with info message
                  if (sendButton && tooltip) {
                    const infoDiv = document.createElement("div");
                    infoDiv.style.marginTop = "40px";
                    infoDiv.style.color = "#31708f";
                    infoDiv.style.background = "#d9edf7";
                    infoDiv.style.border = "1px solid #bce8f1";
                    infoDiv.style.borderRadius = "4px";
                    infoDiv.style.padding = "8px 12px";
                    infoDiv.style.fontSize = "10px";
                    infoDiv.style.textAlign = "left";
                    infoDiv.innerHTML = `
                      <i class="fa fa-info-circle" style="margin-right: 6px;"></i>
                      Remark already saved and cannot be edited.
                    `;
                    sendButton.parentNode.replaceChild(infoDiv, sendButton);
                  }
                  
                  // Find the chat icon <img> inside this trigger
                  const chatImg = trigger.querySelector('img[alt="Chat"]');
                  if (chatImg) {
                    chatImg.style.filter = "grayscale(0) brightness(1.1) sepia(1) hue-rotate(80deg) saturate(3) contrast(1.2)";
                    chatImg.style.opacity = "1";
                  }

                  hideTooltip(); // optional if you still want to hide the tooltip
                });

              } else {
                Swal.fire('Error', data.error || 'Failed to save remark', 'error');
              }
            })
            .catch(() => {
              Swal.fire('Error', 'Network error', 'error');
            });
          });
        }
      });
    });

        function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
</script>

  <!-- Script for Model / Stock No - Image Mouse Hover -->
<script nonce="{{ csp_nonce }}">
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.model-hover-trigger').forEach(function(trigger) {
      const tooltip = trigger.querySelector('.model-image-tooltip');
      let currentIndex = 0;
      let tooltipPinned = false;
      const images = Array.from(tooltip.querySelectorAll('.img-gallery img'));

      function showImages(start) {
        images.forEach((img, i) => {
          img.style.display = (i >= start && i < start + 3) ? 'block' : 'none';
        });
      }
      showImages(currentIndex);

      trigger.addEventListener('mouseenter', function() {
        if (!tooltipPinned) {
          tooltip.style.opacity = '1';
          tooltip.style.pointerEvents = 'auto';
        }
      });
      trigger.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
        }
      });
      tooltip.addEventListener('mouseenter', function() {
        if (!tooltipPinned) {
          tooltip.style.opacity = '1';
          tooltip.style.pointerEvents = 'auto';
        }
      });
      tooltip.addEventListener('mouseleave', function() {
        if (!tooltipPinned) {
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
        }
      });

      // Pin tooltip on click
      trigger.addEventListener('click', function(e) {
        e.preventDefault();
        tooltipPinned = true;
        tooltip.style.opacity = '1';
        tooltip.style.pointerEvents = 'auto';
      });

      // Unpin tooltip if user clicks outside
      document.addEventListener('mousedown', function(e) {
        if (!trigger.contains(e.target) && !tooltip.contains(e.target)) {
          tooltipPinned = false;
          tooltip.style.opacity = '0';
          tooltip.style.pointerEvents = 'none';
        }
      });

      tooltip.querySelector('.img-scroll-left').addEventListener('click', function(e) {
        e.stopPropagation();
        if (currentIndex > 0) {
          currentIndex--;
          showImages(currentIndex);
        }
      });
      tooltip.querySelector('.img-scroll-right').addEventListener('click', function(e) {
        e.stopPropagation();
        if (currentIndex < images.length - 3) {
          currentIndex++;
          showImages(currentIndex);
        }
      });

      // Add click event to images for modal slider
      images.forEach(function(img, idx) {
        img.style.cursor = 'pointer';
        img.addEventListener('click', function(e) {
          e.stopPropagation();
          openImageSlider(images.map(i => i.src), idx);
        });
      });
    });

    // Modal slider functions
    const modal = document.getElementById("imageSliderModal");
    const closeModal = document.getElementById("closeImageSliderModal");
    const slidesContainer = modal.querySelector(".slides");
    let sliderImages = [];
    let currentSlide = 0;

    function openImageSlider(srcArray, startIdx) {
      sliderImages = srcArray;
      slidesContainer.innerHTML = '';
      sliderImages.forEach(src => {
        const slide = document.createElement('div');
        slide.className = 'slide';
        const img = document.createElement('img');
        img.src = src;
        slide.appendChild(img);
        slidesContainer.appendChild(slide);
      });
      currentSlide = startIdx;
      showSlide(currentSlide);
      modal.classList.add('open');
    }

    function showSlide(n) {
      const slides = slidesContainer.querySelectorAll('.slide');
      if (!slides.length) return;
      currentSlide = (n + slides.length) % slides.length;
      slides.forEach((slide, idx) => {
        slide.classList.toggle('active', idx === currentSlide);
      });
    }

    modal.querySelector("#prevBtn").addEventListener("click", function(e) {
      e.stopPropagation();
      showSlide(currentSlide - 1);
    });
    modal.querySelector("#nextBtn").addEventListener("click", function(e) {
      e.stopPropagation();
      showSlide(currentSlide + 1);
    });
    closeModal.addEventListener("click", function() {
      modal.classList.remove("open");
    });
    modal.addEventListener("click", function(e) {
      if (e.target === modal) modal.classList.remove("open");
    });
  });
</script>

<!-- Active table row highlight -->
<script nonce="{{ csp_nonce }}">
// Row highlight & position swap for tray-scan-btn-Jig (like DP_PickTable.html)
document.addEventListener("DOMContentLoaded", function() {
  // Add highlight style if not present
  if (!document.getElementById('dp-row-action-highlight-style')) {
    var style = document.createElement('style');
    style.id = 'dp-row-action-highlight-style';
    style.innerHTML = `
      .dp-row-action-highlight {
        transition: box-shadow 1.3s;
        background-color: #f0f8ff !important;
        animation: highlightAnimation 2s ease-in-out;
      }
    `;
    document.head.appendChild(style);
  }

  let originalRowIndex = null;
  let movedRow = null;
  let placeholderRow = null;

  document.querySelectorAll('.tray-scan-btn-Jig').forEach(function(link) {
    link.addEventListener('click', function(event) {
      // Remove highlight from all rows
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
      });
      // Move the clicked row to the top and highlight
      var row = event.target.closest('tr');
      if (row && row.parentNode) {
        const tbody = row.parentNode;
        // Only move if not already at top
        if (tbody.firstElementChild !== row) {
          // If a previous move exists, restore it first
          if (movedRow && placeholderRow && placeholderRow.parentNode) {
            placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
            placeholderRow.parentNode.removeChild(placeholderRow);
            movedRow.classList.remove('dp-row-action-highlight');
            movedRow = null;
            placeholderRow = null;
            originalRowIndex = null;
          }
          // Store original index and row
          originalRowIndex = Array.from(tbody.children).indexOf(row);
          movedRow = row;
          // Insert a placeholder at the original position
          placeholderRow = document.createElement('tr');
          placeholderRow.style.display = 'none';
          tbody.insertBefore(placeholderRow, tbody.children[originalRowIndex]);
          // Move row to top
          tbody.insertBefore(row, tbody.firstElementChild);
        }
        row.classList.add('dp-row-action-highlight');
      }
    });
  });

  // On modal close, restore row to original position and remove highlight
  var closeBtn = document.getElementById('closeTrayScanModal_DayPlanning');
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      if (movedRow && placeholderRow && placeholderRow.parentNode) {
        placeholderRow.parentNode.insertBefore(movedRow, placeholderRow);
        placeholderRow.parentNode.removeChild(placeholderRow);
        movedRow.classList.remove('dp-row-action-highlight');
        movedRow = null;
        placeholderRow = null;
        originalRowIndex = null;
      }
      // Also remove highlight from any row just in case
      document.querySelectorAll('tbody tr').forEach(function(row) {
        row.classList.remove('dp-row-action-highlight');
        row.classList.remove('highlighted-tray-scan');
      });
    });
  }
});
</script>

<script nonce="{{ csp_nonce }}">
// ✅ FIXED: Store state globally so it persists across table refreshes
window.holdToggleState = {
  currentHoldCell: null,
  intendedState: null,
  currentBatchId: null,
  currentLotId: null
};

function attachHoldToggleListeners() {
  console.log('Attaching hold toggle listeners...');

  // Attach batch_id to each row for easy access
  document.querySelectorAll("tbody tr").forEach(function (row) {
    const trayScanBtn = row.querySelector('.tray-scan-btn, .tray-scan-btn-Jig');
    if (trayScanBtn) {
      row.setAttribute('data-batch-id', trayScanBtn.getAttribute('data-batch-id'));
    }
  });

  // Remove existing listeners and attach new ones
  document.querySelectorAll('.hold-toggle-btn').forEach(function (btn) {
    // Remove any existing click listeners
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);
    
    // Add new event listener
    newBtn.addEventListener('click', function (e) {
      e.preventDefault();
      
      const holdCell = newBtn.closest('td');
      const row = holdCell.closest('tr');
      
      // ✅ Store state globally with all needed data
      window.holdToggleState = {
        currentHoldCell: holdCell,
        intendedState: newBtn.checked,
        currentBatchId: row.getAttribute('data-batch-id'),
        currentLotId: row.getAttribute('data-stock-lot-id'),
        // Store identifiers that can help us find the row after refresh
        rowIdentifier: row.getAttribute('data-stock-lot-id') || row.getAttribute('data-batch-id')
      };
      
      console.log('Hold toggle clicked, state:', window.holdToggleState);
      
      document.getElementById('holdRemarkModal').querySelector('h5').textContent = 
        window.holdToggleState.intendedState ? 'Unholding Reason' : 'Holding Reason';
      document.getElementById('holdRemarkInput').value = '';
      document.getElementById('holdRemarkError').textContent = '';
      document.getElementById('holdRemarkModal').style.display = 'flex';
      document.getElementById('holdRemarkInput').focus();
    });
  });

  // ✅ Attach save button handler (only once globally)
  const saveBtn = document.getElementById('saveHoldRemarkBtn');
  if (saveBtn && !window.holdSaveHandlerAttached) {
    window.holdSaveHandlerAttached = true;
    
    saveBtn.onclick = function () {
      console.log('Save button clicked, current state:', window.holdToggleState);
      
      const remark = document.getElementById('holdRemarkInput').value.trim();
      if (!remark) {
        document.getElementById('holdRemarkError').textContent = 'Remark required!';
        return;
      }
      
      // ✅ Use stored state instead of current variables
      if (!window.holdToggleState.currentLotId) {
        document.getElementById('holdRemarkError').textContent = 'Lot ID not found!';
        return;
      }
    
      const action = window.holdToggleState.intendedState ? 'unhold' : 'hold';
      
      console.log('Sending request:', {
        lot_id: window.holdToggleState.currentLotId,
        remark: remark,
        action: action
      });
    
      fetch('/inputscreening/ip_save_hold_unhold_reason/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRFToken': getCookie('csrftoken')
        },
        body: JSON.stringify({
          lot_id: window.holdToggleState.currentLotId,
          remark: remark,
          action: action
        })
      })
      .then(res => res.json())
      .then(data => {
        console.log('Server response:', data);
        
        if (data.success) {
          // ✅ Close modal first
          document.getElementById('holdRemarkModal').style.display = 'none';
          
          // ✅ Update UI immediately before refresh
          const currentRow = document.querySelector(`tr[data-stock-lot-id="${window.holdToggleState.currentLotId}"]`);
          if (currentRow) {
            const toggle = currentRow.querySelector('.hold-toggle-btn');
            const icon = currentRow.querySelector('.hold-remark-icon');
            
            if (action === 'hold') {
              if (toggle) toggle.checked = false;
              currentRow.classList.add('row-inactive');
              currentRow.querySelectorAll('td').forEach((td, idx) => {
                if (idx > 0) {
                  td.classList.add('row-inactive-blur');
                } else {
                  td.classList.remove('row-inactive-blur');
                }
              });
              if (icon) {
                icon.style.display = 'inline-block';
                icon.innerHTML = `<img src="{% static 'assets/icons/view2.png' %}" alt="Remark" style="width:18px; height:18px;" />`;
                icon.setAttribute('title', 'Holding Reason: ' + remark);
              }
            } else {
              if (toggle) toggle.checked = true;
              currentRow.classList.remove('row-inactive');
              currentRow.querySelectorAll('td').forEach(td => {
                td.classList.remove('row-inactive-blur');
              });
              if (icon) {
                icon.style.display = 'none';
              }
            }
          }
          
          // ✅ Then refresh the table data
          setTimeout(() => {
            if (typeof refreshTableData === 'function') {
              refreshTableData();
            } else {
              location.reload();
            }
          }, 500);
          
        } else {
          document.getElementById('holdRemarkError').textContent = data.error || 'Failed to save reason!';
        }
      })
      .catch((error) => {
        console.error('Request failed:', error);
        document.getElementById('holdRemarkError').textContent = 'Network error!';
      });
    };
  }

  // ✅ Attach close button handler (only once globally)
  const closeBtn = document.getElementById('closeHoldRemarkModal');
  if (closeBtn && !window.holdCloseHandlerAttached) {
    window.holdCloseHandlerAttached = true;
    closeBtn.onclick = function () {
      document.getElementById('holdRemarkModal').style.display = 'none';
      // Clear the state when modal is closed
      window.holdToggleState = {
        currentHoldCell: null,
        intendedState: null,
        currentBatchId: null,
        currentLotId: null
      };
    };
  }

  // Helper for CSRF
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
      const cookies = document.cookie.split(';');
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.substring(0, name.length + 1) === (name + '=')) {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
}

// ✅ Call on page load
document.addEventListener("DOMContentLoaded", function () {
  attachHoldToggleListeners();
});
</script>

{% endblock %} {% endblock content %}